<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Quantum Circuit Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .gate {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            font-size: 0.8rem;
            font-weight: 500;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }

        .gate:hover {
            transform: scale(1.1) translateY(-1px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .circuit-cell {
            width: 50px;
            height: 50px;
            border: 1px solid #d1d5db;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: background-color 0.2s;
        }

        .circuit-cell:focus {
            outline: 2px solid #2563eb;
            outline-offset: 1px;
        }


        .circuit-cell:hover {
            background-color: #e5e7eb;
        }

        .circuit-cell.selected {
            background-color: #bfdbfe;
            border-color: #2563eb;
            outline: 2px solid #2563eb;
            outline-offset: -1px;
        }

        .circuit-cell.has-gate {
            background-color: #e0f2fe;
        }

        .circuit-cell.pending-control {
            background-color: #fef3c7;
            border: 2px dashed #f59e0b;
        }

        .chat-message {
            max-width: 85%;
            padding: 0.75rem 1rem;
            border-radius: 1.25rem;
            margin-bottom: 0.75rem;
            line-height: 1.5;
        }

        .user-message {
            background-color: #2563eb;
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 0.5rem;
        }

        .ai-message {
            background-color: #e5e7eb;
            color: #1f2937;
            margin-right: auto;
            border-bottom-left-radius: 0.5rem;
        }

        .ai-message .prose strong {
            color: #374151;
        }

        .ai-message .prose code {
            background-color: #d1d5db;
            color: #111827;
            padding: 0.1em 0.3em;
            border-radius: 4px;
        }

        .ai-message .prose pre {
            background-color: #d1d5db !important;
            color: #111827;
            padding: 0.5rem !important;
            border-radius: 6px !important;
        }


        .quantum-state {
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            white-space: pre-wrap;
            background-color: #f9fafb;
            padding: 1rem;
            border-radius: 0.375rem;
            border: 1px solid #e5e7eb;
            max-height: 400px;
            overflow-y: auto;
        }

        .gate-button.selected-gate-button {
            outline: 3px solid #3b82f6;
            outline-offset: 1px;
            transform: scale(1.05);
            background-color: #93c5fd !important;
        }

        .prose {
            max-width: none;
        }

        .prose-sm {
            font-size: 0.875rem;
            line-height: 1.4rem;
        }

        .control-line {
            position: absolute;
            background-color: #3b82f6;
            width: 3px;
            z-index: 5;
            pointer-events: none;
        }

        #circuit-grid-container {
            position: relative;
        }

        .parameterized-gate-text {
            font-size: 0.65rem;
            /* Smaller text for angles */
            display: block;
            line-height: 1;
            margin-top: 2px;
        }

        .results-section h4 {
            font-size: 1.05em;
            font-weight: 600;
            margin-top: 0.75rem;
            margin-bottom: 0.25rem;
            color: #1d4ed8;
            /* Blue-700 */
        }
    </style>
</head>

<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <header class="mb-10 text-center">
            <h1 class="text-4xl font-bold text-blue-700 mb-3">Quantum Circuit Simulator</h1>
            <p class="text-gray-700 text-lg">Visualize circuits, generate QASM, simulate, and learn with AI.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div class="lg:col-span-1 bg-white rounded-xl shadow-lg p-6 space-y-6">
                <h2 class="text-2xl font-semibold mb-4 text-gray-800 border-b pb-2">Circuit Controls</h2>

                <div>
                    <label for="qubit-count" class="block text-sm font-medium text-gray-700 mb-1">Circuit Setup</label>
                    <div class="flex space-x-2 items-end">
                        <div class="flex-1">
                            <label for="qubit-count" class="block text-xs text-gray-500 mb-1">Qubits</label>
                            <input type="number" id="qubit-count" min="1" max="8" value="2"
                                class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                        <div class="flex-1">
                            <label for="column-count" class="block text-xs text-gray-500 mb-1">Columns</label>
                            <input type="number" id="column-count" min="1" max="20" value="4"
                                class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                        <button id="update-circuit-btn" aria-label="Update circuit dimensions"
                            class="px-3 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 text-sm shadow hover:shadow-md transition-all">
                            Update
                        </button>
                    </div>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Quantum Gates <span id="gate-status"
                            class="text-xs text-gray-500 ml-2 italic"></span></label>
                    <div class="grid grid-cols-4 gap-3">
                        <button data-gate="H" aria-label="Hadamard Gate"
                            class="gate gate-button bg-purple-200 text-purple-800 hover:bg-purple-300">H</button>
                        <button data-gate="X" aria-label="Pauli-X Gate"
                            class="gate gate-button bg-red-200 text-red-800 hover:bg-red-300">X</button>
                        <button data-gate="Y" aria-label="Pauli-Y Gate"
                            class="gate gate-button bg-yellow-200 text-yellow-800 hover:bg-yellow-300">Y</button>
                        <button data-gate="Z" aria-label="Pauli-Z Gate"
                            class="gate gate-button bg-green-200 text-green-800 hover:bg-green-300">Z</button>
                        <button data-gate="S" aria-label="S Gate"
                            class="gate gate-button bg-cyan-200 text-cyan-800 hover:bg-cyan-300">S</button>
                        <button data-gate="T" aria-label="T Gate"
                            class="gate gate-button bg-amber-200 text-amber-800 hover:bg-amber-300">T</button>
                        <button data-gate="RX" aria-label="RX Gate (Rotation X)"
                            class="gate gate-button bg-rose-200 text-rose-800 hover:bg-rose-300">RX</button>
                        <button data-gate="RY" aria-label="RY Gate (Rotation Y)"
                            class="gate gate-button bg-teal-200 text-teal-800 hover:bg-teal-300">RY</button>
                        <button data-gate="RZ" aria-label="RZ Gate (Rotation Z)"
                            class="gate gate-button bg-lime-200 text-lime-800 hover:bg-lime-300">RZ</button>
                        <button data-gate="CNOT" aria-label="Controlled-NOT Gate"
                            class="gate gate-button bg-blue-200 text-blue-800 hover:bg-blue-300">CNOT</button>
                        <button data-gate="SWAP" aria-label="SWAP Gate"
                            class="gate gate-button bg-indigo-200 text-indigo-800 hover:bg-indigo-300">SWAP</button>
                        <button data-gate="Measure" aria-label="Measurement"
                            class="gate gate-button bg-gray-300 text-gray-800 hover:bg-gray-400">M</button>
                        <button data-gate="CLEAR" aria-label="Delete Gate"
                            class="gate gate-button bg-pink-200 text-pink-800 hover:bg-pink-300">Del</button>
                    </div>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Circuit Actions</label>
                    <div class="flex flex-wrap gap-2">
                        <button id="run-simulation-btn"
                            class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 shadow hover:shadow-md transition-all">Run
                            (Counts)</button>
                        <button id="get-statevector-btn"
                            class="px-4 py-2 bg-cyan-600 text-white rounded-md hover:bg-cyan-700 focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:ring-offset-2 shadow hover:shadow-md transition-all">Get
                            Statevector</button>
                        <button id="get-probabilities-btn"
                            class="px-4 py-2 bg-sky-600 text-white rounded-md hover:bg-sky-700 focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-offset-2 shadow hover:shadow-md transition-all">Get
                            Probabilities</button>
                        <button id="clear-circuit-btn"
                            class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 shadow hover:shadow-md transition-all">Clear
                            All</button>
                        <button id="undo-circuit-btn"
                            class="px-4 py-2 bg-yellow-500 text-white rounded-md hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:ring-offset-2 shadow hover:shadow-md transition-all">Undo</button>
                        <button id="export-circuit-btn"
                            class="px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 shadow hover:shadow-md transition-all">Export
                            JSON</button>
                        <button id="import-circuit-btn"
                            class="px-4 py-2 bg-teal-600 text-white rounded-md hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-teal-500 focus:ring-offset-2 shadow hover:shadow-md transition-all">Import
                            JSON</button>
                    </div>
                </div>

                <div>
                    <label for="prebuilt-circuits-select" class="block text-sm font-medium text-gray-700 mb-2">Prebuilt
                        Circuits</label>
                    <select id="prebuilt-circuits-select"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="">Select a circuit...</option>
                        <option value="bell">Bell State (2 qubits)</option>
                        <option value="ghz">GHZ State (3 qubits)</option>
                        <option value="teleport">Quantum Teleportation (3 qubits)</option>
                    </select>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">AI Tools (Gemini API)</label>
                    <div class="flex flex-wrap gap-2">
                        <button id="build-with-ai-btn"
                            class="px-4 py-2 bg-fuchsia-600 text-white rounded-md hover:bg-fuchsia-700 focus:outline-none focus:ring-2 focus:ring-fuchsia-500 focus:ring-offset-2 shadow hover:shadow-md transition-all">Build
                            with AI</button>
                        <button id="explain-circuit-ai-btn"
                            class="px-4 py-2 bg-pink-600 text-white rounded-md hover:bg-pink-700 focus:outline-none focus:ring-2 focus:ring-pink-500 focus:ring-offset-2 shadow hover:shadow-md transition-all">Explain
                            Circuit</button>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-1 bg-white rounded-xl shadow-lg p-6">
                <h2 class="text-2xl font-semibold mb-4 text-gray-800 border-b pb-2">Quantum Circuit</h2>
                <div id="circuit-grid-container"
                    class="overflow-auto mb-4 border border-gray-200 rounded-md p-1 bg-gray-50" role="grid"
                    aria-label="Quantum Circuit Grid">
                </div>
                <div id="circuit-lines-container" class="absolute top-0 left-0 w-full h-full pointer-events-none z-[5]">
                </div>


                <div>
                    <h3 id="qasm-results-heading" class="text-xl font-medium text-gray-700 mb-2">QASM & Analysis Results
                    </h3>
                    <div id="simulation-results-div"
                        class="quantum-state min-h-56 p-4 bg-gray-50 rounded-lg results-section"
                        aria-labelledby="qasm-results-heading">
                        <p class="text-gray-500 italic">Generated QASM and analysis results will appear here.</p>
                    </div>
                </div>
            </div>

            <div class="lg:col-span-1 bg-white rounded-xl shadow-lg p-6 flex flex-col">
                <h2 id="chat-heading" class="text-2xl font-semibold mb-4 text-gray-800 border-b pb-2">Quantum Tutor</h2>
                <div id="chat-messages-container"
                    class="flex-grow h-96 overflow-y-auto mb-4 space-y-3 p-3 bg-gray-50 rounded-lg border border-gray-200"
                    role="log" aria-labelledby="chat-heading">
                    <div class="ai-message prose prose-sm">
                        <p>Hello! I'm your Quantum Computing tutor. Ask me anything about quantum circuits, gates, or
                            algorithms. How can I assist you today?</p>
                    </div>
                </div>
                <div class="flex mt-auto">
                    <input id="chat-input-field" type="text" placeholder="Ask a quantum question..."
                        aria-label="Chat input for Quantum Tutor"
                        class="flex-1 px-4 py-2.5 border border-gray-300 rounded-l-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                    <button id="send-chat-btn" aria-label="Send chat message"
                        class="px-5 py-2.5 bg-indigo-600 text-white rounded-r-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-1 shadow hover:shadow-md transition-all">Send</button>
                </div>
            </div>
        </div>
    </div>

    <div id="ai-build-modal"
        class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center hidden z-50 p-4" role="dialog"
        aria-modal="true" aria-labelledby="ai-build-modal-heading">
        <div class="bg-white rounded-lg p-6 w-full max-w-lg shadow-xl">
            <h3 id="ai-build-modal-heading" class="text-xl font-semibold text-gray-800 mb-4">Build Circuit with AI</h3>
            <p class="text-sm text-gray-600 mb-4">Describe the quantum circuit you want to create (e.g., "a 3-qubit GHZ
                state" or "apply Hadamard to qubit 0, then CNOT from 0 to 1").</p>
            <textarea id="ai-build-prompt-textarea" rows="4" aria-label="AI circuit description prompt"
                class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 mb-4"
                placeholder="e.g., Create a 2-qubit Bell state"></textarea>
            <div class="flex justify-end space-x-3">
                <button id="cancel-ai-build-btn"
                    class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 transition-colors">Cancel</button>
                <button id="submit-ai-build-btn"
                    class="px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 transition-colors shadow hover:shadow-md">Generate</button>
            </div>
        </div>
    </div>

    <div id="import-json-modal"
        class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center hidden z-50 p-4" role="dialog"
        aria-modal="true" aria-labelledby="import-json-modal-heading">
        <div class="bg-white rounded-lg p-6 w-full max-w-lg shadow-xl">
            <h3 id="import-json-modal-heading" class="text-xl font-semibold text-gray-800 mb-4">Import Circuit JSON</h3>
            <p class="text-sm text-gray-600 mb-4">Paste the circuit JSON data:</p>
            <textarea id="import-json-textarea" rows="6" aria-label="Paste circuit JSON data here"
                class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 mb-4 font-mono text-sm"></textarea>
            <div class="flex justify-end space-x-3">
                <button id="cancel-import-json-btn"
                    class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 transition-colors">Cancel</button>
                <button id="submit-import-json-btn"
                    class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition-colors shadow hover:shadow-md">Import</button>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', function () {
            const GEMINI_API_KEY = 'AIzaSyDYsp56kfUrkBA7cfvzlkabbVVSoF_Co4c'; // Your Gemini API Key
            const GEMINI_API_URL_BASE = 'https://generativelanguage.googleapis.com/v1beta/models/';
            const GEMINI_MODEL = 'gemini-1.5-flash-latest'; // Or 'gemini-pro' or other suitable model

            const FLASK_BACKEND_URL_SIMULATE = 'http://127.0.0.1:5000/simulate';
            const FLASK_BACKEND_URL_STATEVECTOR = 'http://127.0.0.1:5000/get_statevector';
            const FLASK_BACKEND_URL_PROBABILITIES = 'http://127.0.0.1:5000/get_probabilities';
            const YOUR_GEMINI_API_KEY_PLACEHOLDER = 'YOUR_GEMINI_API_KEY_HERE'; // For checks, though we're hardcoding above

            let circuit = { qubits: 2, columns: 4, gates: [] };
            let selectedGate = null;
            let pendingMultiQubitOp = null;
            let lastClickedCellCoords = null;
            let aiChatHistory = [{ role: 'model', content: "Hello! I'm your Quantum Computing tutor. Ask me anything!" }]; // Gemini uses 'model' for assistant
            let circuitHistory = [];
            const MAX_HISTORY_STATES = 20;

            const qubitCountInput = document.getElementById('qubit-count');
            const columnCountInput = document.getElementById('column-count');
            const updateCircuitBtn = document.getElementById('update-circuit-btn');
            const circuitGridContainer = document.getElementById('circuit-grid-container');
            const circuitLinesContainer = document.getElementById('circuit-lines-container');
            const simulationResultsDiv = document.getElementById('simulation-results-div');
            const gateStatusSpan = document.getElementById('gate-status');

            const runSimulationBtn = document.getElementById('run-simulation-btn');
            const getStatevectorBtn = document.getElementById('get-statevector-btn');
            const getProbabilitiesBtn = document.getElementById('get-probabilities-btn');
            const clearCircuitBtn = document.getElementById('clear-circuit-btn');
            const undoCircuitBtn = document.getElementById('undo-circuit-btn');
            const exportCircuitBtn = document.getElementById('export-circuit-btn');
            const importCircuitBtn = document.getElementById('import-circuit-btn');
            const prebuiltCircuitsSelect = document.getElementById('prebuilt-circuits-select');
            const buildWithAiBtn = document.getElementById('build-with-ai-btn');
            const explainCircuitAiBtn = document.getElementById('explain-circuit-ai-btn');
            const aiBuildModal = document.getElementById('ai-build-modal');
            const aiBuildPromptTextarea = document.getElementById('ai-build-prompt-textarea');
            const cancelAiBuildBtn = document.getElementById('cancel-ai-build-btn');
            const submitAiBuildBtn = document.getElementById('submit-ai-build-btn');
            const importJsonModal = document.getElementById('import-json-modal');
            const importJsonTextarea = document.getElementById('import-json-textarea');
            const cancelImportJsonBtn = document.getElementById('cancel-import-json-btn');
            const submitImportJsonBtn = document.getElementById('submit-import-json-btn');
            const chatMessagesContainer = document.getElementById('chat-messages-container');
            const chatInputField = document.getElementById('chat-input-field');
            const sendChatBtn = document.getElementById('send-chat-btn');

            initializeCircuitState();
            setupEventListeners();

            function saveCircuitState() {
                if (circuitHistory.length >= MAX_HISTORY_STATES) circuitHistory.shift();
                circuitHistory.push({
                    qubits: circuit.qubits,
                    columns: circuit.columns,
                    gates: JSON.parse(JSON.stringify(circuit.gates))
                });
                updateUndoButtonState();
            }

            function undoLastAction() {
                if (circuitHistory.length > 1) {
                    circuitHistory.pop();
                    const prevState = circuitHistory[circuitHistory.length - 1];
                    Object.assign(circuit, {
                        qubits: prevState.qubits,
                        columns: prevState.columns,
                        gates: JSON.parse(JSON.stringify(prevState.gates))
                    });
                    qubitCountInput.value = circuit.qubits;
                    columnCountInput.value = circuit.columns;
                    clearGateSelection();
                    renderCircuitGrid();
                    simulationResultsDiv.innerHTML = '<p class="text-gray-500 italic">Circuit state restored.</p>';
                } else if (circuitHistory.length === 1) {
                    const initialEmptyState = circuitHistory[0];
                    Object.assign(circuit, initialEmptyState);
                    circuit.gates = JSON.parse(JSON.stringify(initialEmptyState.gates));
                    qubitCountInput.value = circuit.qubits;
                    columnCountInput.value = circuit.columns;
                    clearGateSelection(); renderCircuitGrid();
                    simulationResultsDiv.innerHTML = '<p class="text-gray-500 italic">Circuit reset to initial state.</p>';
                    circuitHistory = [];
                } else {
                    alert("No more actions to undo.");
                }
                updateUndoButtonState();
            }

            function updateUndoButtonState() {
                undoCircuitBtn.disabled = circuitHistory.length === 0;
                undoCircuitBtn.classList.toggle('opacity-50', circuitHistory.length === 0);
                undoCircuitBtn.classList.toggle('cursor-not-allowed', circuitHistory.length === 0);
            }

            function initializeCircuitState(fromUserAction = false) {
                if (fromUserAction) saveCircuitState();
                circuit.qubits = parseInt(qubitCountInput.value);
                circuit.columns = parseInt(columnCountInput.value);
                circuit.gates = Array(circuit.qubits).fill(null).map(() => Array(circuit.columns).fill(null));
                if (!fromUserAction || circuitHistory.length === 0) {
                    circuitHistory = []; saveCircuitState();
                }
                clearGateSelection(); renderCircuitGrid();
                simulationResultsDiv.innerHTML = '<p class="text-gray-500 italic">Circuit updated. Analyze or run simulation.</p>';
            }

            function renderCircuitGrid() {
                circuitGridContainer.innerHTML = ''; circuitLinesContainer.innerHTML = '';
                const headerDiv = document.createElement('div');
                headerDiv.className = 'flex sticky top-0 bg-gray-50 z-20';
                const qubitLabelHeader = document.createElement('div');
                qubitLabelHeader.className = 'w-16 h-10 flex items-center justify-center text-xs text-gray-600 font-medium sticky left-0 bg-gray-50 z-10';
                qubitLabelHeader.textContent = 'Qubit'; headerDiv.appendChild(qubitLabelHeader);
                for (let c = 0; c < circuit.columns; c++) {
                    const colHeader = document.createElement('div');
                    colHeader.className = 'w-[50px] h-10 flex items-center justify-center text-xs text-gray-600 font-medium';
                    colHeader.textContent = `${c}`; headerDiv.appendChild(colHeader);
                }
                circuitGridContainer.appendChild(headerDiv);

                for (let q = 0; q < circuit.qubits; q++) {
                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'flex'; rowDiv.style.position = 'relative';
                    const qubitLabel = document.createElement('div');
                    qubitLabel.className = 'w-16 h-[50px] flex items-center justify-center text-sm font-medium text-gray-700 sticky left-0 bg-gray-50 z-10 border-r border-gray-200';
                    qubitLabel.textContent = `Q${q}`; rowDiv.appendChild(qubitLabel);

                    for (let c = 0; c < circuit.columns; c++) {
                        const cellDiv = document.createElement('div');
                        cellDiv.className = 'circuit-cell';
                        Object.assign(cellDiv.dataset, { qubit: q, column: c });
                        cellDiv.id = `cell-${q}-${c}`;
                        cellDiv.setAttribute('role', 'button'); cellDiv.setAttribute('tabindex', '0');

                        if (lastClickedCellCoords && lastClickedCellCoords.qubit === q && lastClickedCellCoords.column === c) {
                            cellDiv.classList.add('selected');
                        }
                        const gateData = circuit.gates[q][c];
                        let gateDescForAria = "empty";
                        if (gateData) {
                            const gateDiv = document.createElement('div');
                            let displaySymbol = '', bgColor = 'bg-sky-100', textColor = 'text-sky-800', gateType = '', gateAngle = null;
                            if (typeof gateData === 'string') gateType = displaySymbol = gateData;
                            else if (typeof gateData === 'object' && gateData.type) {
                                gateType = gateData.type; gateAngle = gateData.angle; displaySymbol = gateType;
                            }

                            if (gateType === 'H') { bgColor = 'bg-purple-200'; textColor = 'text-purple-800'; gateDescForAria = "Hadamard"; }
                            else if (gateType === 'X') { bgColor = 'bg-red-200'; textColor = 'text-red-800'; gateDescForAria = "Pauli-X"; }
                            else if (gateType === 'Y') { bgColor = 'bg-yellow-200'; textColor = 'text-yellow-800'; gateDescForAria = "Pauli-Y"; }
                            else if (gateType === 'Z') { bgColor = 'bg-green-200'; textColor = 'text-green-800'; gateDescForAria = "Pauli-Z"; }
                            else if (gateType === 'S') { bgColor = 'bg-cyan-200'; textColor = 'text-cyan-800'; gateDescForAria = "S"; }
                            else if (gateType === 'T') { bgColor = 'bg-amber-200'; textColor = 'text-amber-800'; gateDescForAria = "T"; }
                            else if (gateType === 'RX') { bgColor = 'bg-rose-200'; textColor = 'text-rose-800'; gateDescForAria = "Rotation X"; }
                            else if (gateType === 'RY') { bgColor = 'bg-teal-200'; textColor = 'text-teal-800'; gateDescForAria = "Rotation Y"; }
                            else if (gateType === 'RZ') { bgColor = 'bg-lime-200'; textColor = 'text-lime-800'; gateDescForAria = "Rotation Z"; }
                            else if (gateType === 'Measure') { displaySymbol = 'M'; bgColor = 'bg-gray-300'; textColor = 'text-gray-800'; gateDescForAria = "Measure"; }
                            else if (gateType === 'CNOT-C') { displaySymbol = '●'; bgColor = 'bg-blue-300'; textColor = 'text-blue-900'; gateDescForAria = "CNOT control"; }
                            else if (gateType === 'CNOT-T') { displaySymbol = '⊕'; bgColor = 'bg-blue-200'; textColor = 'text-blue-800'; gateDescForAria = "CNOT target"; }
                            else if (gateType === 'SWAP') { displaySymbol = '✕'; bgColor = 'bg-indigo-200'; textColor = 'text-indigo-800'; gateDescForAria = "SWAP"; }

                            cellDiv.classList.add(bgColor.replace('bg-', 'border-') + '-focus', 'has-gate');
                            gateDiv.className = `gate ${bgColor} ${textColor} flex flex-col items-center justify-center`;
                            gateDiv.innerHTML = `<span>${displaySymbol}</span>`;
                            if (gateAngle !== null) {
                                const angleText = document.createElement('span');
                                angleText.className = 'parameterized-gate-text';
                                angleText.textContent = `(${gateAngle.toFixed(2)})`;
                                gateDiv.appendChild(angleText);
                                gateDescForAria += ` angle ${gateAngle.toFixed(2)} rad`;
                            }
                            cellDiv.appendChild(gateDiv);
                        }
                        cellDiv.setAttribute('aria-label', `Circuit cell Qubit ${q}, Column ${c}, ${gateDescForAria}`);

                        if (pendingMultiQubitOp && pendingMultiQubitOp.controlQubit === q && pendingMultiQubitOp.column === c && !gateData) {
                            const pendingText = document.createElement('div');
                            pendingText.className = 'text-xs text-yellow-700 italic font-semibold';
                            pendingText.textContent = pendingMultiQubitOp.type.charAt(0) + '-Ctrl?';
                            cellDiv.appendChild(pendingText);
                        }
                        cellDiv.addEventListener('click', () => handleCellClick(q, c, cellDiv));
                        cellDiv.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); handleCellClick(q, c, cellDiv); } });
                        rowDiv.appendChild(cellDiv);
                    }
                    circuitGridContainer.appendChild(rowDiv);
                }
                drawConnectingLines();
            }

            function drawConnectingLines() {
                circuitLinesContainer.innerHTML = '';
                const cellWidth = 50, cellHeight = 50;
                const qubitLabelWidth = document.querySelector('.w-16').offsetWidth;
                const colHeaderHeight = document.querySelector('.h-10').offsetHeight;

                for (let c = 0; c < circuit.columns; c++) {
                    let controlQubits = [], targetQubits = [], swapQubits = [];
                    for (let q = 0; q < circuit.qubits; q++) {
                        const gateData = circuit.gates[q][c];
                        const gateType = typeof gateData === 'string' ? gateData : (gateData && gateData.type);
                        if (gateType === 'CNOT-C') controlQubits.push(q);
                        if (gateType === 'CNOT-T') targetQubits.push(q);
                        if (gateType === 'SWAP') swapQubits.push(q);
                    }
                    if (controlQubits.length > 0 && targetQubits.length > 0) {
                        const q1 = Math.min(...controlQubits, ...targetQubits), q2 = Math.max(...controlQubits, ...targetQubits);
                        const line = document.createElement('div'); line.className = 'control-line';
                        const xPos = qubitLabelWidth + (c * cellWidth) + (cellWidth / 2) - 1.5;
                        const yTop = colHeaderHeight + (q1 * cellHeight) + (cellHeight / 2);
                        line.style.cssText = `left:${xPos}px; top:${yTop}px; height:${(q2 - q1) * cellHeight}px;`;
                        if ((q2 - q1) * cellHeight > 0) circuitLinesContainer.appendChild(line);
                    }
                    if (swapQubits.length === 2) {
                        const q1 = swapQubits[0], q2 = swapQubits[1];
                        const line = document.createElement('div'); line.className = 'control-line'; line.style.backgroundColor = '#5b21b6';
                        const xPos = qubitLabelWidth + (c * cellWidth) + (cellWidth / 2) - 1.5;
                        const yTop = colHeaderHeight + (Math.min(q1, q2) * cellHeight) + (cellHeight / 2);
                        line.style.cssText = `left:${xPos}px; top:${yTop}px; height:${Math.abs(q1 - q2) * cellHeight}px; background-color: #5b21b6;`;
                        if (Math.abs(q1 - q2) * cellHeight > 0) circuitLinesContainer.appendChild(line);
                    }
                }
            }

            function handleCellClick(qubit, column, cellElement) {
                saveCircuitState();
                document.querySelectorAll('.circuit-cell.selected').forEach(c => c.classList.remove('selected'));
                cellElement.classList.add('selected');
                lastClickedCellCoords = { qubit, column };

                if (pendingMultiQubitOp) {
                    if (pendingMultiQubitOp.column === column && pendingMultiQubitOp.controlQubit !== qubit) {
                        const { type, controlQubit, column: controlCol } = pendingMultiQubitOp;
                        circuit.gates[controlQubit][controlCol] = null; circuit.gates[qubit][column] = null;
                        if (type === 'CNOT') { circuit.gates[controlQubit][controlCol] = 'CNOT-C'; circuit.gates[qubit][column] = 'CNOT-T'; }
                        else if (type === 'SWAP') { circuit.gates[controlQubit][controlCol] = 'SWAP'; circuit.gates[qubit][column] = 'SWAP'; }
                        clearGateSelection();
                    } else {
                        alert(`Invalid target for ${pendingMultiQubitOp.type}. Must be different qubit in same column. Cancelling.`);
                        clearGateSelection();
                    }
                } else if (selectedGate) {
                    const gateType = selectedGate.type;
                    if (gateType === 'CNOT' || gateType === 'SWAP') {
                        circuit.gates[qubit][column] = null;
                        pendingMultiQubitOp = { type: gateType, controlQubit: qubit, column: column };
                        updateGateStatusDisplay();
                    } else if (gateType === 'CLEAR') circuit.gates[qubit][column] = null;
                    else if (['RX', 'RY', 'RZ'].includes(gateType)) {
                        const angleRad = parseFloat(prompt(`Enter angle in radians for ${gateType} (e.g., ${Math.PI.toFixed(4)} for Pi):`, (Math.PI / 2).toFixed(4)));
                        if (!isNaN(angleRad)) circuit.gates[qubit][column] = { type: gateType, angle: angleRad };
                        else alert("Invalid angle. Gate not placed.");
                    } else circuit.gates[qubit][column] = gateType;
                }
                renderCircuitGrid();
            }

            function clearGateSelection() {
                selectedGate = null; pendingMultiQubitOp = null;
                updateSelectedGateButtonStyle(); updateGateStatusDisplay();
                if (lastClickedCellCoords) renderCircuitGrid();
            }

            function updateSelectedGateButtonStyle() {
                document.querySelectorAll('.gate-button').forEach(btn => {
                    btn.classList.remove('ring-4', 'ring-offset-2', 'ring-blue-500', 'selected-gate-button', 'scale-110', 'z-10', 'bg-blue-300');
                    if (selectedGate && btn.getAttribute('data-gate') === selectedGate.type) {
                        btn.classList.add('ring-4', 'ring-offset-2', 'ring-blue-500', 'selected-gate-button', 'scale-110', 'z-10');
                    }
                });
            }

            function updateGateStatusDisplay() {
                if (!selectedGate && !pendingMultiQubitOp) { gateStatusSpan.textContent = "Select a gate or action."; return; }
                if (pendingMultiQubitOp) gateStatusSpan.textContent = `Placing ${pendingMultiQubitOp.type}. Click target in col ${pendingMultiQubitOp.column}. (Q${pendingMultiQubitOp.controlQubit} is ctrl/first).`;
                else if (selectedGate) {
                    const gateType = selectedGate.type;
                    if (['CNOT', 'SWAP'].includes(gateType)) gateStatusSpan.textContent = `Selected ${gateType}. Click control/first qubit.`;
                    else if (gateType === 'CLEAR') gateStatusSpan.textContent = `Selected Delete. Click cell to clear.`;
                    else if (['RX', 'RY', 'RZ'].includes(gateType)) gateStatusSpan.textContent = `Selected ${gateType}. Click cell. Angle will be prompted.`;
                    else gateStatusSpan.textContent = `Selected ${gateType}. Click cell to place.`;
                }
            }

            function clearFullCircuit() {
                if (confirm('Clear entire circuit? (Can be undone)')) {
                    saveCircuitState();
                    circuit.gates = Array(circuit.qubits).fill(null).map(() => Array(circuit.columns).fill(null));
                    clearGateSelection(); renderCircuitGrid();
                    simulationResultsDiv.innerHTML = '<p class="text-gray-500 italic">Circuit cleared.</p>';
                }
            }

            function generateQASM() {
                let qasmString = `OPENQASM 2.0;\ninclude "qelib1.inc";\nqreg q[${circuit.qubits}];\n`;
                let hasMeasurement = false;
                circuit.gates.forEach(row => row.forEach(g => { if (g && (g === 'Measure' || g.type === 'Measure')) hasMeasurement = true; }));
                if (hasMeasurement) qasmString += `creg c[${circuit.qubits}];\n`;

                const processedMulti = {};
                for (let c = 0; c < circuit.columns; c++) {
                    processedMulti[c] = new Set();
                    for (let q = 0; q < circuit.qubits; q++) {
                        const gateData = circuit.gates[q][c];
                        if (!gateData || processedMulti[c].has(q)) continue;
                        const q_idx = `q[${q}]`, c_idx = `c[${q}]`;
                        let gateType = typeof gateData === 'string' ? gateData : (gateData.type || '');
                        let gateAngle = typeof gateData === 'object' ? gateData.angle : null;

                        switch (gateType) {
                            case 'H': qasmString += `h ${q_idx};\n`; break;
                            case 'X': qasmString += `x ${q_idx};\n`; break;
                            case 'Y': qasmString += `y ${q_idx};\n`; break;
                            case 'Z': qasmString += `z ${q_idx};\n`; break;
                            case 'S': qasmString += `s ${q_idx};\n`; break;
                            case 'T': qasmString += `t ${q_idx};\n`; break;
                            case 'RX': qasmString += `rx(${gateAngle !== null ? gateAngle : 0}) ${q_idx};\n`; break;
                            case 'RY': qasmString += `ry(${gateAngle !== null ? gateAngle : 0}) ${q_idx};\n`; break;
                            case 'RZ': qasmString += `rz(${gateAngle !== null ? gateAngle : 0}) ${q_idx};\n`; break;
                            case 'Measure': qasmString += `measure ${q_idx} -> ${c_idx};\n`; break;
                            case 'CNOT-C':
                                let targetQ_cnot = -1;
                                for (let tq = 0; tq < circuit.qubits; tq++) {
                                    const tg = circuit.gates[tq][c]; if (tg && (typeof tg === 'string' ? tg : tg.type) === 'CNOT-T' && tq !== q) { targetQ_cnot = tq; break; }
                                }
                                if (targetQ_cnot !== -1) { qasmString += `cx ${q_idx},q[${targetQ_cnot}];\n`; processedMulti[c].add(targetQ_cnot); }
                                else qasmString += `// Warn: CNOT-C @ q[${q}],c[${c}] no target.\n`;
                                break;
                            case 'SWAP':
                                let partnerQ_swap = -1;
                                for (let pq = 0; pq < circuit.qubits; pq++) {
                                    const pg = circuit.gates[pq][c]; if (pq !== q && pg && (typeof pg === 'string' ? pg : pg.type) === 'SWAP') { partnerQ_swap = pq; break; }
                                }
                                if (partnerQ_swap !== -1 && !processedMulti[c].has(partnerQ_swap)) { qasmString += `swap ${q_idx},q[${partnerQ_swap}];\n`; processedMulti[c].add(partnerQ_swap); }
                                else if (partnerQ_swap === -1 && !processedMulti[c].has(q)) qasmString += `// Warn: SWAP @ q[${q}],c[${c}] no partner.\n`;
                                break;
                        }
                        processedMulti[c].add(q);
                    }
                }
                return qasmString;
            }

            async function runSimulationWithCounts() {
                const qasmCode = generateQASM();
                let htmlOutput = `<h4>Generated QASM 2.0 (for Counts):</h4><pre class="whitespace-pre-wrap break-all text-sm p-2 bg-gray-100 rounded border">${qasmCode.replace(/</g, "<").replace(/>/g, ">")}</pre>`;
                simulationResultsDiv.innerHTML = htmlOutput + "<p class='text-indigo-600 animate-pulse mt-2 font-medium'>Sending to backend for counts simulation...</p>";

                try {
                    const response = await fetch(FLASK_BACKEND_URL_SIMULATE, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ qasm: qasmCode, shots: 1024 }) });
                    const resultData = await response.json();
                    if (!response.ok) throw new Error(resultData.error || `Backend Error: ${response.status}`);

                    htmlOutput += `<hr class='my-3 border-gray-300'><h4>Simulation Results (Counts):</h4>`;
                    htmlOutput += `<p class="text-sm text-gray-600"><strong>Status:</strong> ${resultData.message || 'Success!'} (${resultData.backend_used || 'N/A'})</p>`;
                    if (resultData.job_id) htmlOutput += `<p class="text-xs text-gray-500">Job ID: ${resultData.job_id}</p>`;
                    htmlOutput += `<p class="text-sm text-gray-600"><strong>Shots:</strong> ${resultData.shots || 'N/A'}</p>`;
                    htmlOutput += `<h5 class="font-semibold mt-2 mb-1 text-gray-700">Counts:</h5>`;
                    if (resultData.counts && Object.keys(resultData.counts).length > 0) {
                        htmlOutput += `<pre class="text-sm whitespace-pre-wrap break-all p-2 bg-gray-100 rounded border">${JSON.stringify(resultData.counts, null, 2)}</pre>`;
                    } else htmlOutput += `<p class="text-sm italic text-gray-500">No counts returned.</p>`;
                    simulationResultsDiv.innerHTML = htmlOutput;
                } catch (error) {
                    simulationResultsDiv.innerHTML = htmlOutput + `<p class='text-red-600 mt-2 font-semibold'><strong>Error:</strong> ${error.message}</p>`;
                }
            }

            async function getStatevectorFromBackend() {
                const qasmCode = generateQASM();
                let htmlOutput = `<h4>Generated QASM 2.0 (for Statevector):</h4><pre class="whitespace-pre-wrap break-all text-sm p-2 bg-gray-100 rounded border">${qasmCode.replace(/</g, "<").replace(/>/g, ">")}</pre>`;
                simulationResultsDiv.innerHTML = htmlOutput + "<p class='text-indigo-600 animate-pulse mt-2 font-medium'>Requesting statevector from backend...</p>";

                try {
                    const response = await fetch(FLASK_BACKEND_URL_STATEVECTOR, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ qasm: qasmCode }) });
                    const resultData = await response.json();
                    if (!response.ok) throw new Error(resultData.error || `Backend Error: ${response.status}`);

                    htmlOutput += `<hr class='my-3 border-gray-300'><h4>Statevector Results:</h4>`;
                    htmlOutput += `<p class="text-sm text-gray-600"><strong>Status:</strong> ${resultData.message || 'Success!'} (${resultData.backend_used || 'N/A'})</p>`;
                    htmlOutput += `<p class="text-sm text-gray-600"><strong>Qubits:</strong> ${resultData.num_qubits}</p>`;
                    htmlOutput += `<h5 class="font-semibold mt-2 mb-1 text-gray-700">Statevector Amplitudes (|Ψ⟩):</h5>`;
                    if (resultData.statevector && resultData.statevector.length > 0) {
                        let svTable = '<div class="overflow-x-auto"><table class="min-w-full text-xs table-fixed"><thead><tr><th class="px-1 py-1 border">Basis State</th><th class="px-1 py-1 border">Amplitude (Real)</th><th class="px-1 py-1 border">Amplitude (Imag)</th><th class="px-1 py-1 border">Probability</th></tr></thead><tbody>';
                        resultData.statevector.forEach((amp, i) => {
                            const basisState = i.toString(2).padStart(resultData.num_qubits, '0');
                            const probability = amp[0] * amp[0] + amp[1] * amp[1];
                            svTable += `<tr><td class="border px-1 py-1 text-center">|${basisState}⟩</td><td class="border px-1 py-1 text-right">${amp[0].toFixed(5)}</td><td class="border px-1 py-1 text-right">${amp[1].toFixed(5)}</td><td class="border px-1 py-1 text-right">${probability.toFixed(5)}</td></tr>`;
                        });
                        svTable += '</tbody></table></div>';
                        htmlOutput += svTable;
                    } else htmlOutput += `<p class="text-sm italic text-gray-500">No statevector data returned.</p>`;
                    simulationResultsDiv.innerHTML = htmlOutput;
                } catch (error) {
                    simulationResultsDiv.innerHTML = htmlOutput + `<p class='text-red-600 mt-2 font-semibold'><strong>Error:</strong> ${error.message}</p>`;
                }
            }

            async function getProbabilitiesFromBackend() {
                const qasmCode = generateQASM();
                let htmlOutput = `<h4>Generated QASM 2.0 (for Probabilities):</h4><pre class="whitespace-pre-wrap break-all text-sm p-2 bg-gray-100 rounded border">${qasmCode.replace(/</g, "<").replace(/>/g, ">")}</pre>`;
                simulationResultsDiv.innerHTML = htmlOutput + "<p class='text-indigo-600 animate-pulse mt-2 font-medium'>Requesting ideal probabilities from backend...</p>";

                try {
                    const response = await fetch(FLASK_BACKEND_URL_PROBABILITIES, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ qasm: qasmCode }) });
                    const resultData = await response.json();
                    if (!response.ok) throw new Error(resultData.error || `Backend Error: ${response.status}`);

                    htmlOutput += `<hr class='my-3 border-gray-300'><h4>Ideal Probabilities (from Statevector):</h4>`;
                    htmlOutput += `<p class="text-sm text-gray-600"><strong>Status:</strong> ${resultData.message || 'Success!'} (${resultData.backend_used || 'N/A'})</p>`;
                    htmlOutput += `<p class="text-sm text-gray-600"><strong>Qubits:</strong> ${resultData.num_qubits}</p>`;
                    htmlOutput += `<h5 class="font-semibold mt-2 mb-1 text-gray-700">Probabilities:</h5>`;
                    if (resultData.probabilities && Object.keys(resultData.probabilities).length > 0) {
                        let probText = '<div class="space-y-1 text-xs">';
                        const maxBarLength = 30;
                        for (const basisState in resultData.probabilities) {
                            const prob = resultData.probabilities[basisState];
                            const barLength = Math.round(prob * maxBarLength);
                            const bar = '█'.repeat(barLength) + ' '.repeat(maxBarLength - barLength);
                            probText += `<div>|${basisState}⟩: ${prob.toFixed(5)} <span class="text-blue-500">[${bar}]</span></div>`;
                        }
                        probText += '</div>';
                        htmlOutput += probText;

                    } else htmlOutput += `<p class="text-sm italic text-gray-500">No probability data returned.</p>`;
                    simulationResultsDiv.innerHTML = htmlOutput;
                } catch (error) {
                    simulationResultsDiv.innerHTML = htmlOutput + `<p class='text-red-600 mt-2 font-semibold'><strong>Error:</strong> ${error.message}</p>`;
                }
            }

            function exportCircuitToJSON() {
                const circuitData = { qubits: circuit.qubits, columns: circuit.columns, gates: circuit.gates };
                const dataStr = JSON.stringify(circuitData, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
                const exportFileDefaultName = `quantum-circuit-${new Date().toISOString().slice(0, 10)}.json`;
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
            }
            function showImportModal() { importJsonTextarea.value = ''; importJsonModal.classList.remove('hidden'); }
            function hideImportModal() { importJsonModal.classList.add('hidden'); }
            function importCircuitFromJSON() {
                saveCircuitState();
                try {
                    const imported = JSON.parse(importJsonTextarea.value);
                    if (!imported.qubits || !imported.columns || !Array.isArray(imported.gates)) {
                        throw new Error('Invalid circuit data. Missing qubits, columns, or gates array.');
                    }
                    if (imported.gates.length !== imported.qubits || (imported.qubits > 0 && imported.gates.some(row => !Array.isArray(row) || row.length !== imported.columns))) {
                        throw new Error('Gate array dimensions do not match qubit and column counts or is malformed.');
                    }

                    circuit.qubits = imported.qubits;
                    circuit.columns = imported.columns;
                    circuit.gates = imported.gates;

                    qubitCountInput.value = circuit.qubits;
                    columnCountInput.value = circuit.columns;

                    clearGateSelection();
                    renderCircuitGrid();
                    hideImportModal();
                    simulationResultsDiv.innerHTML = '<p class="text-gray-500 italic">Circuit imported. Run simulation.</p>';
                } catch (error) {
                    alert('Error importing circuit: ' + error.message);
                }
            }
            function loadPrebuiltCircuit() {
                const circuitType = prebuiltCircuitsSelect.value;
                if (!circuitType) return;
                saveCircuitState();
                let newCircuitData;
                switch (circuitType) {
                    case 'bell':
                        newCircuitData = { qubits: 2, columns: 2, gates: [['H', 'CNOT-C'], [null, 'CNOT-T']] };
                        break;
                    case 'ghz':
                        newCircuitData = { qubits: 3, columns: 3, gates: [['H', 'CNOT-C', null], [null, 'CNOT-T', 'CNOT-C'], [null, null, 'CNOT-T']] };
                        break;
                    case 'teleport':
                        newCircuitData = {
                            qubits: 3, columns: 7,
                            gates: [
                                [{ type: 'RX', angle: 0.785 }, 'H', 'CNOT-C', null, 'H', 'Measure', null],
                                ['H', 'CNOT-C', 'CNOT-T', 'Measure', null, null, 'X'],
                                ['CNOT-T', null, null, 'Measure', null, null, 'Z']
                            ]
                        };
                        alert("Note: Teleportation circuit's final X/Z are typically classically controlled. This visualizer applies them directly.");
                        break;
                    default: return;
                }
                circuit.qubits = newCircuitData.qubits;
                circuit.columns = newCircuitData.columns;
                circuit.gates = newCircuitData.gates;
                qubitCountInput.value = circuit.qubits;
                columnCountInput.value = circuit.columns;
                clearGateSelection();
                renderCircuitGrid();
                simulationResultsDiv.innerHTML = `<p class="text-gray-500 italic">${circuitType} circuit loaded. Run simulation.</p>`;
                prebuiltCircuitsSelect.value = '';
            }

            function showAiBuildModal() { aiBuildPromptTextarea.value = ''; aiBuildModal.classList.remove('hidden'); }
            function hideAiBuildModal() { aiBuildModal.classList.add('hidden'); }

            async function buildCircuitWithAI() {
                const userPromptText = aiBuildPromptTextarea.value.trim();
                if (!userPromptText) { alert('Please describe the circuit.'); return; }
                if (!GEMINI_API_KEY || GEMINI_API_KEY === YOUR_GEMINI_API_KEY_PLACEHOLDER) {
                    alert("Gemini API Key not configured. AI features disabled.");
                    simulationResultsDiv.innerHTML = "<p class='text-red-500'>AI Build disabled: Gemini API Key not set.</p>";
                    hideAiBuildModal();
                    return;
                }
                saveCircuitState();
                hideAiBuildModal();
                simulationResultsDiv.innerHTML = '<p class="text-indigo-600 animate-pulse font-medium">Generating circuit with AI...</p>';

                const systemInstruction = `You are a quantum computing expert. Convert user's description into a JSON quantum circuit.
Respond ONLY with the JSON object, without any surrounding text, comments, or markdown.
The JSON structure should be: {"qubits":int, "columns":int, "gates":array[qubit][column], "description":str}.
'gates' is a 2D array. Each element can be null (no gate), a string for a simple gate, or an object for a parameterized gate.
Valid simple gate strings: "H", "X", "Y", "Z", "S", "T", "Measure", "CNOT-C", "CNOT-T", "SWAP".
Parameterized gates are objects: {"type": "RX", "angle": float_in_radians}, {"type": "RY", "angle": float_in_radians}, {"type": "RZ", "angle": float_in_radians}.
CNOT-C (control) and CNOT-T (target) must be in the same column on different qubits.
SWAP must appear on both involved qubits in the same column (two "SWAP" strings).
Ensure the dimensions of the 'gates' array are correct (qubits rows, columns cols).
Example for a 2-qubit Bell state with an RZ(pi/2) on q0 first:
{"qubits": 2, "columns": 3, "description": "Bell state with initial RZ on q0.", "gates": [[{"type":"RZ", "angle":1.5708}, "H", "CNOT-C"], [null, null, "CNOT-T"]]}
If the user doesn't specify enough columns, try to make it compact but readable. Max qubits 8, max columns 20.
User's request will follow.`;

                const fullPrompt = `${systemInstruction}\n\nUser's request: ${userPromptText}`;

                try {
                    const response = await fetch(`${GEMINI_API_URL_BASE}${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: [{ role: "user", parts: [{ text: fullPrompt }] }],
                            generationConfig: { temperature: 0.1, responseMimeType: "application/json" } // Request JSON output
                        })
                    });

                    const responseData = await response.json();

                    if (!response.ok || !responseData.candidates || !responseData.candidates[0].content || !responseData.candidates[0].content.parts || !responseData.candidates[0].content.parts[0].text) {
                        const errorDetail = responseData.error ? JSON.stringify(responseData.error) : (responseData.candidates && responseData.candidates[0].finishReason ? `Finish Reason: ${responseData.candidates[0].finishReason}` : 'Unknown AI API error');
                        throw new Error(`AI API error: ${response.status} - ${errorDetail}`);
                    }

                    const aiResponseContent = responseData.candidates[0].content.parts[0].text;
                    let circuitData;
                    try {
                        // The response should be clean JSON if responseMimeType worked.
                        // If not, attempt to extract from markdown.
                        const jsonMatch = aiResponseContent.match(/```json\n([\s\S]*?)\n```/);
                        circuitData = JSON.parse(jsonMatch ? jsonMatch[1] : aiResponseContent);

                    } catch (e) { throw new Error('AI response was not valid JSON: ' + e.message + "\nRaw Response from AI: " + aiResponseContent); }


                    if (!circuitData.qubits || !circuitData.columns || !Array.isArray(circuitData.gates) || typeof circuitData.description !== 'string') {
                        throw new Error('AI response missing required fields (qubits, columns, gates, description).');
                    }
                    if (circuitData.gates.length !== circuitData.qubits ||
                        (circuitData.qubits > 0 && circuitData.gates.some(row => !Array.isArray(row) || row.length !== circuitData.columns))) {
                        throw new Error('AI response gate array dimensions do not match qubit and column counts or is malformed.');
                    }
                    for (let q_val = 0; q_val < circuitData.qubits; q_val++) {
                        for (let c_val = 0; c_val < circuitData.columns; c_val++) {
                            const gate = circuitData.gates[q_val][c_val];
                            if (gate !== null && typeof gate !== 'string' && (typeof gate !== 'object' || !gate.type)) {
                                throw new Error(`Invalid gate data at Q${q_val}, C${c_val}: ${JSON.stringify(gate)}`);
                            }
                            if (typeof gate === 'object' && (gate.type === 'RX' || gate.type === 'RY' || gate.type === 'RZ') && typeof gate.angle !== 'number') {
                                throw new Error(`Parameterized gate ${gate.type} at Q${q_val}, C${c_val} missing valid 'angle'.`);
                            }
                        }
                    }

                    circuit.qubits = Math.min(8, Math.max(1, parseInt(circuitData.qubits) || 2));
                    circuit.columns = Math.min(20, Math.max(1, parseInt(circuitData.columns) || 4));
                    circuit.gates = circuitData.gates;
                    qubitCountInput.value = circuit.qubits;
                    columnCountInput.value = circuit.columns;
                    clearGateSelection();
                    renderCircuitGrid();
                    simulationResultsDiv.innerHTML = `<div><p class="font-semibold text-green-700 mb-1">AI-Generated Circuit:</p><p class="text-sm mb-2">${circuitData.description}</p><button onclick="document.getElementById('run-simulation-btn').click()" class="px-3 py-1.5 bg-green-600 text-white rounded-md text-sm shadow hover:shadow-md transition-all">Run (Counts)</button></div>`;
                } catch (error) {
                    simulationResultsDiv.innerHTML = `<div class="text-red-600"><p class="font-semibold">Error with AI Build:</p><p class="text-sm">${error.message}</p></div>`;
                    console.error('AI Build error:', error);
                }
            }

            async function explainCircuitAI() {
                if (circuit.gates.every(row => row.every(gateData => gateData === null))) {
                    alert('Circuit is empty. Add gates first.'); return;
                }
                if (!GEMINI_API_KEY || GEMINI_API_KEY === YOUR_GEMINI_API_KEY_PLACEHOLDER) {
                    alert("Gemini API Key not configured. AI features disabled.");
                    simulationResultsDiv.innerHTML = "<p class='text-red-500'>AI Explain disabled: Gemini API Key not set.</p>";
                    return;
                }
                simulationResultsDiv.innerHTML = '<p class="text-indigo-600 animate-pulse font-medium">AI is generating explanation...</p>';

                const systemPrompt = "You are a quantum computing educator. Explain the given circuit (qubits, columns, gates array) concisely in markdown. Gate objects like {\"type\":\"RX\", \"angle\":1.57} mean RX gate with angle 1.57 radians. Identify standard algorithms if any. Use clear, beginner-friendly language but be accurate.";
                const userPrompt = `Explain this circuit: Qubits: ${circuit.qubits}, Columns: ${circuit.columns}, Gates: ${JSON.stringify(circuit.gates)}`;

                const geminiContents = [
                    { role: "user", parts: [{ text: systemPrompt }] },
                    { role: "model", parts: [{ text: "Understood. I will explain the quantum circuit based on the provided data." }] },
                    { role: "user", parts: [{ text: userPrompt }] }
                ];

                try {
                    const response = await fetch(`${GEMINI_API_URL_BASE}${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiContents,
                            generationConfig: { temperature: 0.4 }
                        })
                    });
                    const data = await response.json();
                    if (!response.ok || !data.candidates || !data.candidates[0].content || !data.candidates[0].content.parts[0].text) {
                        const errorDetail = data.error ? JSON.stringify(data.error) : (data.candidates && data.candidates[0].finishReason ? `Finish Reason: ${data.candidates[0].finishReason}` : 'Unknown AI API error');
                        throw new Error(`AI API error: ${response.status} - ${errorDetail}`);
                    }
                    const explanation = data.candidates[0].content.parts[0].text;

                    const formattedExplanation = explanation
                        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                        .replace(/\*(.*?)\*/g, '<em>$1</em>')
                        .replace(/```([\s\S]*?)```/g, (match, p1) => `<pre class="bg-gray-200 p-2 rounded text-sm my-1 whitespace-pre-wrap">${p1.trim()}</pre>`)
                        .replace(/`(.*?)`/g, '<code class="bg-gray-200 px-1 rounded text-sm">$1</code>')
                        .replace(/\n/g, '<br/>');

                    simulationResultsDiv.innerHTML = `<div><p class="font-semibold text-purple-700 mb-2">AI Circuit Explanation:</p><div class="prose prose-sm max-w-none">${formattedExplanation}</div></div>`;
                } catch (error) {
                    simulationResultsDiv.innerHTML = `<div class="text-red-600"><p class="font-semibold">Error with AI Explanation:</p><p class="text-sm">${error.message}</p></div>`;
                    console.error('AI Explain error:', error);
                }
            }

            function addMessageToChatUI(role, content, id = null) {
                const messageDiv = document.createElement('div');
                // Gemini uses 'user' and 'model' (model is like assistant)
                messageDiv.className = `chat-message ${role === 'user' ? 'user-message' : 'ai-message'}`;
                if (id) messageDiv.id = id;

                const formattedContent = content
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/```([\s\S]*?)```/g, (match, p1) => `<pre class="bg-gray-300 text-gray-800 p-2 rounded text-sm my-1 whitespace-pre-wrap">${p1.trim()}</pre>`)
                    .replace(/`(.*?)`/g, '<code class="bg-gray-300 text-gray-800 px-1 rounded text-sm">$1</code>')
                    .replace(/\n/g, '<br/>');

                messageDiv.innerHTML = `<div class="prose prose-sm max-w-none">${formattedContent}</div>`;
                chatMessagesContainer.appendChild(messageDiv);
                chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
            }

            async function sendChatMessage() {
                const userMessage = chatInputField.value.trim();
                if (!userMessage) return;
                if (!GEMINI_API_KEY || GEMINI_API_KEY === YOUR_GEMINI_API_KEY_PLACEHOLDER) {
                    addMessageToChatUI('model', "AI Tutor disabled: Gemini API Key not configured in the script.");
                    chatInputField.value = '';
                    return;
                }

                addMessageToChatUI('user', userMessage);
                aiChatHistory.push({ role: 'user', parts: [{ text: userMessage }] }); // Gemini format
                chatInputField.value = '';

                const loadingId = 'ai-loading-' + Date.now();
                addMessageToChatUI('model', '<span class="italic text-gray-600">Tutor is thinking...</span>', loadingId);

                // Prepare chat history for Gemini API (user/model alternation)
                let geminiChatContents = [
                    { role: "user", parts: [{ text: "You are a Quantum Computing Tutor. Answer concisely in markdown. Explain concepts clearly for beginners. If asked to write code, prefer Qiskit/Python examples unless specified." }] },
                    { role: "model", parts: [{ text: "Understood. I will act as a Quantum Computing Tutor." }] }
                ];
                // Map existing history, ensuring correct roles
                aiChatHistory.slice(-12).forEach(msg => {
                    // The initial message in aiChatHistory is 'model', the rest should alternate
                    if (msg.role === 'user' || msg.role === 'model') { // Check if it's already in Gemini format
                        geminiChatContents.push({ role: msg.role, parts: msg.parts || [{ text: msg.content }] });
                    } else if (msg.role === 'assistant') { // Convert from old format if necessary
                        geminiChatContents.push({ role: 'model', parts: [{ text: msg.content }] });
                    }
                });


                try {
                    const response = await fetch(`${GEMINI_API_URL_BASE}${GEMINI_MODEL}:generateContent?key=${GEMINI_API_KEY}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            contents: geminiChatContents,
                            generationConfig: { temperature: 0.5 }
                        })
                    });
                    const data = await response.json();
                    const loadingElement = document.getElementById(loadingId);

                    if (!response.ok || !data.candidates || !data.candidates[0].content || !data.candidates[0].content.parts[0].text) {
                        const errorDetail = data.error ? JSON.stringify(data.error) : (data.candidates && data.candidates[0].finishReason ? `Finish Reason: ${data.candidates[0].finishReason}` : 'Unknown AI API error');
                        if (loadingElement) loadingElement.innerHTML = `<div class="prose prose-sm text-red-600">Error: ${errorDetail}</div>`;
                        else addMessageToChatUI('model', `Error: ${errorDetail}`);
                        throw new Error(errorDetail);
                    }

                    const aiResponse = data.candidates[0].content.parts[0].text;
                    aiChatHistory.push({ role: 'model', parts: [{ text: aiResponse }] }); // Save in Gemini format
                    if (loadingElement) {
                        const formattedResponse = aiResponse
                            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                            .replace(/\*(.*?)\*/g, '<em>$1</em>')
                            .replace(/```([\s\S]*?)```/g, (match, p1) => `<pre class="bg-gray-300 text-gray-800 p-2 rounded text-sm my-1 whitespace-pre-wrap">${p1.trim()}</pre>`)
                            .replace(/`(.*?)`/g, '<code class="bg-gray-300 text-gray-800 px-1 rounded text-sm">$1</code>')
                            .replace(/\n/g, '<br/>');
                        loadingElement.innerHTML = `<div class="prose prose-sm max-w-none">${formattedResponse}</div>`;
                    } else {
                        addMessageToChatUI('model', aiResponse);
                    }

                } catch (error) {
                    console.error('AI Chat error:', error);
                    const loadingElement = document.getElementById(loadingId);
                    if (loadingElement) loadingElement.innerHTML = `<div class="prose prose-sm text-red-600">Chat Error: ${error.message}</div>`;
                    else addMessageToChatUI('model', `Chat Error: ${error.message}`);
                }
            }

            function setupEventListeners() {
                updateCircuitBtn.addEventListener('click', () => initializeCircuitState(true));
                document.querySelectorAll('.gate-button').forEach(button => {
                    button.addEventListener('click', function () {
                        const gateTypeFromButton = this.getAttribute('data-gate');
                        if (selectedGate && selectedGate.type === gateTypeFromButton && !pendingMultiQubitOp) clearGateSelection();
                        else { selectedGate = { type: gateTypeFromButton }; pendingMultiQubitOp = null; updateSelectedGateButtonStyle(); updateGateStatusDisplay(); }
                    });
                });
                runSimulationBtn.addEventListener('click', runSimulationWithCounts);
                getStatevectorBtn.addEventListener('click', getStatevectorFromBackend);
                getProbabilitiesBtn.addEventListener('click', getProbabilitiesFromBackend);
                clearCircuitBtn.addEventListener('click', clearFullCircuit);
                undoCircuitBtn.addEventListener('click', undoLastAction);
                exportCircuitBtn.addEventListener('click', exportCircuitToJSON);
                importCircuitBtn.addEventListener('click', showImportModal);
                cancelImportJsonBtn.addEventListener('click', hideImportModal);
                submitImportJsonBtn.addEventListener('click', importCircuitFromJSON);
                prebuiltCircuitsSelect.addEventListener('change', loadPrebuiltCircuit);
                buildWithAiBtn.addEventListener('click', showAiBuildModal);
                cancelAiBuildBtn.addEventListener('click', hideAiBuildModal);
                submitAiBuildBtn.addEventListener('click', buildCircuitWithAI);
                explainCircuitAiBtn.addEventListener('click', explainCircuitAI);
                sendChatBtn.addEventListener('click', sendChatMessage);
                chatInputField.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendChatMessage(); } });
                updateUndoButtonState();
            }
        });
    </script>
</body>

</html>