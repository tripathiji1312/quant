<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Quantum Circuit Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* --- Base & Layout --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            /* --- MODIFIED: Nicer font --- */
        }

        .gate {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            /* --- MODIFIED: Softer rounding --- */
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            /* --- MODIFIED: Smoother transition --- */
            font-size: 0.8rem;
            font-weight: 500;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            /* --- NEW: Subtle shadow --- */
        }

        .gate:hover {
            transform: scale(1.1) translateY(-1px);
            /* --- MODIFIED: More engaging hover --- */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .circuit-cell {
            width: 50px;
            height: 50px;
            border: 1px solid #d1d5db;
            /* --- MODIFIED: Slightly darker border --- */
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            /* --- NEW: For connecting lines --- */
            transition: background-color 0.2s;
        }

        .circuit-cell:hover {
            background-color: #e5e7eb;
            /* --- MODIFIED: Softer hover --- */
        }

        .circuit-cell.selected {
            background-color: #bfdbfe;
            /* --- MODIFIED: Clearer selection --- */
            border-color: #2563eb;
            outline: 2px solid #2563eb;
            outline-offset: -1px;
        }

        .circuit-cell.has-gate {
            background-color: #e0f2fe;
            /* Light blue, can vary based on gate */
        }

        .circuit-cell.pending-control {
            background-color: #fef3c7;
            /* Lighter yellow */
            border: 2px dashed #f59e0b;
            /* Dashed border for pending */
        }

        /* --- MODIFIED: Chat message styling --- */
        .chat-message {
            max-width: 85%;
            padding: 0.75rem 1rem;
            border-radius: 1.25rem;
            /* Softer bubbles */
            margin-bottom: 0.75rem;
            line-height: 1.5;
        }

        .user-message {
            background-color: #2563eb;
            /* Vibrant blue */
            color: white;
            margin-left: auto;
            border-bottom-right-radius: 0.5rem;
        }

        .ai-message {
            background-color: #e5e7eb;
            /* Light gray */
            color: #1f2937;
            margin-right: auto;
            border-bottom-left-radius: 0.5rem;
        }

        .ai-message .prose strong {
            color: #374151;
        }

        .ai-message .prose code {
            background-color: #d1d5db;
            color: #111827;
            padding: 0.1em 0.3em;
            border-radius: 4px;
        }

        .ai-message .prose pre {
            background-color: #d1d5db !important;
            color: #111827;
            padding: 0.5rem !important;
            border-radius: 6px !important;
        }


        .quantum-state {
            font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
            /* --- MODIFIED: Better mono stack --- */
            white-space: pre-wrap;
            background-color: #f9fafb;
            /* Lighter gray */
            padding: 1rem;
            border-radius: 0.375rem;
            /* Tailwind's rounded-md */
            border: 1px solid #e5e7eb;
            max-height: 400px;
            overflow-y: auto;
        }

        .gate-button.selected-gate-button {
            outline: 3px solid #3b82f6;
            /* --- MODIFIED: Thicker outline for selected gate tool --- */
            outline-offset: 1px;
            transform: scale(1.05);
            background-color: #93c5fd !important;
            /* Force a highlight */
        }

        .prose {
            max-width: none;
        }

        .prose-sm {
            font-size: 0.875rem;
            line-height: 1.4rem;
        }

        /* --- NEW: Styles for connecting lines --- */
        .control-line {
            position: absolute;
            background-color: #3b82f6;
            /* Blue-600 */
            width: 3px;
            z-index: 5;
            /* Below gates but above cell background */
            pointer-events: none;
            /* Lines should not be clickable */
        }

        #circuit-grid-container {
            position: relative;
            /* For absolute positioning of lines */
        }
    </style>
</head>

<body class="bg-gray-100 min-h-screen"> {/* --- MODIFIED: Slightly darker page background --- */}
    <div class="container mx-auto px-4 py-8">
        <header class="mb-10 text-center"> {/* --- MODIFIED: Centered header --- */}
            <h1 class="text-4xl font-bold text-blue-700 mb-3">Quantum Circuit Simulator</h1> {/* --- MODIFIED: Larger,
            bolder --- */}
            <p class="text-gray-700 text-lg">Visualize circuits, generate QASM, simulate, and learn with AI.</p> {/* ---
            MODIFIED: Clearer subtext --- */}
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6"> {/* --- MODIFIED: Reduced gap slightly --- */}
            <!-- Left Panel - Controls -->
            <div class="lg:col-span-1 bg-white rounded-xl shadow-lg p-6 space-y-6"> {/* --- MODIFIED: Softer shadow,
                more padding --- */}
                <h2 class="text-2xl font-semibold mb-4 text-gray-800 border-b pb-2">Circuit Controls</h2> {/* ---
                MODIFIED: Larger, border --- */}

                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-1">Circuit Setup</label>
                    <div class="flex space-x-2 items-end">
                        <div class="flex-1">
                            <label class="block text-xs text-gray-500 mb-1">Qubits</label>
                            <input type="number" id="qubit-count" min="1" max="8" value="2"
                                class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                        <div class="flex-1">
                            <label class="block text-xs text-gray-500 mb-1">Columns</label>
                            <input type="number" id="column-count" min="1" max="20" value="4"
                                class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        </div>
                        <button id="update-circuit-btn"
                            class="px-3 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 text-sm shadow hover:shadow-md transition-all">
                            Update
                        </button>
                    </div>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Quantum Gates <span id="gate-status"
                            class="text-xs text-gray-500 ml-2 italic"></span></label> {/* --- MODIFIED: Italic status
                    --- */}
                    <div class="grid grid-cols-4 gap-3"> {/* --- MODIFIED: Increased gap --- */}
                        <button data-gate="H"
                            class="gate gate-button bg-purple-200 text-purple-800 hover:bg-purple-300">H</button>
                        <button data-gate="X"
                            class="gate gate-button bg-red-200 text-red-800 hover:bg-red-300">X</button>
                        <button data-gate="Y"
                            class="gate gate-button bg-yellow-200 text-yellow-800 hover:bg-yellow-300">Y</button>
                        <button data-gate="Z"
                            class="gate gate-button bg-green-200 text-green-800 hover:bg-green-300">Z</button>
                        <button data-gate="CNOT"
                            class="gate gate-button bg-blue-200 text-blue-800 hover:bg-blue-300">CNOT</button>
                        <button data-gate="SWAP"
                            class="gate gate-button bg-indigo-200 text-indigo-800 hover:bg-indigo-300">SWAP</button>
                        <button data-gate="S"
                            class="gate gate-button bg-cyan-200 text-cyan-800 hover:bg-cyan-300">S</button>
                        <button data-gate="T"
                            class="gate gate-button bg-amber-200 text-amber-800 hover:bg-amber-300">T</button>
                        <button data-gate="Measure"
                            class="gate gate-button bg-gray-300 text-gray-800 hover:bg-gray-400">M</button>
                        <button data-gate="CLEAR"
                            class="gate gate-button bg-pink-200 text-pink-800 hover:bg-pink-300">Del</button> {/* ---
                        MODIFIED: Color for delete --- */}
                    </div>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Circuit Actions</label>
                    <div class="flex flex-wrap gap-2">
                        <button id="run-simulation-btn"
                            class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2 shadow hover:shadow-md transition-all">Run
                            Simulation</button>
                        <button id="clear-circuit-btn"
                            class="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2 shadow hover:shadow-md transition-all">Clear
                            All</button> {/* --- MODIFIED: Red for clear --- */}
                        <button id="undo-circuit-btn"
                            class="px-4 py-2 bg-yellow-500 text-white rounded-md hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-yellow-500 focus:ring-offset-2 shadow hover:shadow-md transition-all">Undo</button>
                        {/* --- NEW: Undo Button --- */}
                        <button id="export-circuit-btn"
                            class="px-4 py-2 bg-sky-600 text-white rounded-md hover:bg-sky-700 focus:outline-none focus:ring-2 focus:ring-sky-500 focus:ring-offset-2 shadow hover:shadow-md transition-all">Export
                            JSON</button>
                        <button id="import-circuit-btn"
                            class="px-4 py-2 bg-teal-600 text-white rounded-md hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-teal-500 focus:ring-offset-2 shadow hover:shadow-md transition-all">Import
                            JSON</button>
                    </div>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">Prebuilt Circuits</label>
                    <select id="prebuilt-circuits-select"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="">Select a circuit...</option>
                        <option value="bell">Bell State (2 qubits)</option>
                        <option value="ghz">GHZ State (3 qubits)</option>
                        <option value="teleport">Quantum Teleportation (3 qubits)</option> {/* --- NEW: More prebuilt
                        --- */}
                    </select>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700 mb-2">AI Tools (OpenRouter API)</label>
                    <div class="flex flex-wrap gap-2">
                        <button id="build-with-ai-btn"
                            class="px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2 shadow hover:shadow-md transition-all">Build
                            with AI</button>
                        <button id="explain-circuit-ai-btn"
                            class="px-4 py-2 bg-pink-600 text-white rounded-md hover:bg-pink-700 focus:outline-none focus:ring-2 focus:ring-pink-500 focus:ring-offset-2 shadow hover:shadow-md transition-all">Explain
                            Circuit</button>
                    </div>
                </div>
            </div>

            <!-- Middle Panel - Circuit -->
            <div class="lg:col-span-1 bg-white rounded-xl shadow-lg p-6"> {/* --- MODIFIED: Softer shadow, more padding
                --- */}
                <h2 class="text-2xl font-semibold mb-4 text-gray-800 border-b pb-2">Quantum Circuit</h2>
                <div id="circuit-grid-container"
                    class="overflow-auto mb-4 border border-gray-200 rounded-md p-1 bg-gray-50"> {/* --- MODIFIED:
                    Border and bg for grid --- */}
                    {/* Circuit grid will be generated here */}
                </div>
                <div id="circuit-lines-container" class="absolute top-0 left-0 w-full h-full pointer-events-none z-[5]">
                    {/* Connecting lines will be drawn here */}
                </div>


                <div>
                    <h3 class="text-xl font-medium text-gray-700 mb-2">QASM & Simulation Results</h3> {/* --- MODIFIED:
                    Larger --- */}
                    <div id="simulation-results-div" class="quantum-state min-h-56 p-4 bg-gray-50 rounded-lg"> {/* ---
                        MODIFIED: Consistent styling --- */}
                        <p class="text-gray-500 italic">Generated QASM and simulation results will appear here.</p>
                    </div>
                </div>
            </div>

            <!-- Right Panel - AI Chat -->
            <div class="lg:col-span-1 bg-white rounded-xl shadow-lg p-6 flex flex-col"> {/* --- MODIFIED: Softer shadow,
                more padding, flex for chat --- */}
                <h2 class="text-2xl font-semibold mb-4 text-gray-800 border-b pb-2">Quantum Tutor</h2>
                <div id="chat-messages-container"
                    class="flex-grow h-96 overflow-y-auto mb-4 space-y-3 p-3 bg-gray-50 rounded-lg border border-gray-200">
                    {/* --- MODIFIED: Consistent style --- */}
                    <div class="ai-message prose prose-sm">
                        <p>Hello! I'm your Quantum Computing tutor. Ask me anything about quantum circuits, gates, or
                            algorithms. How can I assist you today?</p>
                    </div>
                </div>
                <div class="flex mt-auto"> {/* --- MODIFIED: Push to bottom --- */}
                    <input id="chat-input-field" type="text" placeholder="Ask a quantum question..."
                        class="flex-1 px-4 py-2.5 border border-gray-300 rounded-l-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 text-sm">
                    {/* --- MODIFIED: Larger, rounded-lg --- */}
                    <button id="send-chat-btn"
                        class="px-5 py-2.5 bg-indigo-600 text-white rounded-r-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-1 shadow hover:shadow-md transition-all">Send</button>
                    {/* --- MODIFIED: Consistent style --- */}
                </div>
            </div>
        </div>
    </div>

    <!-- Modal for AI Build -->
    <div id="ai-build-modal"
        class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center hidden z-50 p-4"> {/* --- MODIFIED:
        Darker overlay --- */}
        <div class="bg-white rounded-lg p-6 w-full max-w-lg shadow-xl"> {/* --- MODIFIED: Larger, shadow --- */}
            <h3 class="text-xl font-semibold text-gray-800 mb-4">Build Circuit with AI</h3>
            <p class="text-sm text-gray-600 mb-4">Describe the quantum circuit you want to create (e.g., "a 3-qubit GHZ
                state" or "apply Hadamard to qubit 0, then CNOT from 0 to 1").</p>
            <textarea id="ai-build-prompt-textarea" rows="4"
                class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 mb-4"
                placeholder="e.g., Create a 2-qubit Bell state"></textarea>
            <div class="flex justify-end space-x-3">
                <button id="cancel-ai-build-btn"
                    class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 transition-colors">Cancel</button>
                <button id="submit-ai-build-btn"
                    class="px-4 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 transition-colors shadow hover:shadow-md">Generate</button>
            </div>
        </div>
    </div>

    <!-- Modal for Import JSON -->
    <div id="import-json-modal"
        class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center hidden z-50 p-4">
        <div class="bg-white rounded-lg p-6 w-full max-w-lg shadow-xl">
            <h3 class="text-xl font-semibold text-gray-800 mb-4">Import Circuit JSON</h3>
            <p class="text-sm text-gray-600 mb-4">Paste the circuit JSON data:</p>
            <textarea id="import-json-textarea" rows="6"
                class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 mb-4 font-mono text-sm"></textarea>
            <div class="flex justify-end space-x-3">
                <button id="cancel-import-json-btn"
                    class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300 transition-colors">Cancel</button>
                <button id="submit-import-json-btn"
                    class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition-colors shadow hover:shadow-md">Import</button>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // --- CONFIGURATION ---
            const OPENROUTER_API_KEY = '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';
            const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
            const FLASK_BACKEND_URL = 'http://127.0.0.1:5000/simulate';
            const YOUR_OPENROUTER_API_KEY_PLACEHOLDER = 'YOUR_OPENROUTER_API_KEY_HERE';

            // --- STATE ---
            let circuit = {
                qubits: 2,
                columns: 4,
                gates: []
            };
            let selectedGateType = null;
            let pendingMultiQubitOp = null;
            let lastClickedCellCoords = null;
            let aiChatHistory = [
                { role: 'assistant', content: "Hello! I'm your Quantum Computing tutor. Ask me anything!" }
            ];
            // --- NEW: Undo History ---
            let circuitHistory = [];
            const MAX_HISTORY_STATES = 20;


            // --- DOM ELEMENTS ---
            const qubitCountInput = document.getElementById('qubit-count');
            const columnCountInput = document.getElementById('column-count');
            const updateCircuitBtn = document.getElementById('update-circuit-btn');
            const circuitGridContainer = document.getElementById('circuit-grid-container');
            const circuitLinesContainer = document.getElementById('circuit-lines-container'); // --- NEW ---
            const simulationResultsDiv = document.getElementById('simulation-results-div');
            const gateStatusSpan = document.getElementById('gate-status');

            const runSimulationBtn = document.getElementById('run-simulation-btn');
            const clearCircuitBtn = document.getElementById('clear-circuit-btn');
            const undoCircuitBtn = document.getElementById('undo-circuit-btn'); // --- NEW ---
            const exportCircuitBtn = document.getElementById('export-circuit-btn');
            const importCircuitBtn = document.getElementById('import-circuit-btn');
            const prebuiltCircuitsSelect = document.getElementById('prebuilt-circuits-select');

            const buildWithAiBtn = document.getElementById('build-with-ai-btn');
            const explainCircuitAiBtn = document.getElementById('explain-circuit-ai-btn');
            const aiBuildModal = document.getElementById('ai-build-modal');
            const aiBuildPromptTextarea = document.getElementById('ai-build-prompt-textarea');
            const cancelAiBuildBtn = document.getElementById('cancel-ai-build-btn');
            const submitAiBuildBtn = document.getElementById('submit-ai-build-btn');

            const importJsonModal = document.getElementById('import-json-modal');
            const importJsonTextarea = document.getElementById('import-json-textarea');
            const cancelImportJsonBtn = document.getElementById('cancel-import-json-btn');
            const submitImportJsonBtn = document.getElementById('submit-import-json-btn');

            const chatMessagesContainer = document.getElementById('chat-messages-container');
            const chatInputField = document.getElementById('chat-input-field');
            const sendChatBtn = document.getElementById('send-chat-btn');

            // --- INITIALIZATION ---
            initializeCircuitState();
            setupEventListeners();

            // --- NEW: Circuit History Management ---
            function saveCircuitState() {
                if (circuitHistory.length >= MAX_HISTORY_STATES) {
                    circuitHistory.shift(); // Remove oldest state
                }
                // Deep copy of the gates array, and current dimensions
                const stateToSave = {
                    qubits: circuit.qubits,
                    columns: circuit.columns,
                    gates: JSON.parse(JSON.stringify(circuit.gates))
                };
                circuitHistory.push(stateToSave);
                updateUndoButtonState();
            }

            function undoLastAction() {
                if (circuitHistory.length > 1) { // Keep the initial empty state as a baseline if needed, or allow undo to initial
                    circuitHistory.pop(); // Remove current state
                    const prevState = circuitHistory[circuitHistory.length - 1];

                    circuit.qubits = prevState.qubits;
                    circuit.columns = prevState.columns;
                    circuit.gates = JSON.parse(JSON.stringify(prevState.gates)); // Deep copy

                    // Update UI elements that reflect qubits/columns
                    qubitCountInput.value = circuit.qubits;
                    columnCountInput.value = circuit.columns;

                    clearGateSelection(); // Reset any pending operations
                    renderCircuitGrid();
                    simulationResultsDiv.innerHTML = '<p class="text-gray-500 italic">Circuit state restored. Run simulation if needed.</p>';
                } else if (circuitHistory.length === 1) { // Last state before empty
                    const initialEmptyState = circuitHistory[0];
                    circuit.qubits = initialEmptyState.qubits;
                    circuit.columns = initialEmptyState.columns;
                    circuit.gates = JSON.parse(JSON.stringify(initialEmptyState.gates));
                    qubitCountInput.value = circuit.qubits;
                    columnCountInput.value = circuit.columns;
                    clearGateSelection();
                    renderCircuitGrid();
                    simulationResultsDiv.innerHTML = '<p class="text-gray-500 italic">Circuit reset to initial (likely empty) state.</p>';
                    circuitHistory = []; // Clear history as we are at the "true" initial
                }
                else {
                    alert("No more actions to undo.");
                }
                updateUndoButtonState();
            }

            function updateUndoButtonState() {
                undoCircuitBtn.disabled = circuitHistory.length === 0;
                undoCircuitBtn.classList.toggle('opacity-50', circuitHistory.length === 0);
                undoCircuitBtn.classList.toggle('cursor-not-allowed', circuitHistory.length === 0);
            }


            // --- CORE CIRCUIT LOGIC ---
            function initializeCircuitState(fromUserAction = false) {
                if (fromUserAction) saveCircuitState(); // Save state before updating if triggered by user (e.g. update button)

                circuit.qubits = parseInt(qubitCountInput.value);
                circuit.columns = parseInt(columnCountInput.value);
                circuit.gates = Array(circuit.qubits).fill(null).map(() => Array(circuit.columns).fill(null));

                if (!fromUserAction || circuitHistory.length === 0) { // If initial load or history is empty
                    circuitHistory = []; // Reset history
                    saveCircuitState(); // Save this initial empty/new state
                }
                clearGateSelection();
                renderCircuitGrid();
                simulationResultsDiv.innerHTML = '<p class="text-gray-500 italic">Circuit updated. Run simulation to see results.</p>';
            }

            function renderCircuitGrid() {
                circuitGridContainer.innerHTML = '';
                circuitLinesContainer.innerHTML = ''; // --- NEW: Clear lines ---

                const headerDiv = document.createElement('div');
                headerDiv.className = 'flex sticky top-0 bg-gray-50 z-20'; // --- MODIFIED: Sticky header for grid scroll ---
                const qubitLabelHeader = document.createElement('div');
                qubitLabelHeader.className = 'w-16 h-10 flex items-center justify-center text-xs text-gray-600 font-medium sticky left-0 bg-gray-50 z-10';
                qubitLabelHeader.textContent = 'Qubit';
                headerDiv.appendChild(qubitLabelHeader);

                for (let c = 0; c < circuit.columns; c++) {
                    const colHeader = document.createElement('div');
                    colHeader.className = 'w-[50px] h-10 flex items-center justify-center text-xs text-gray-600 font-medium';
                    colHeader.textContent = `${c}`;
                    headerDiv.appendChild(colHeader);
                }
                circuitGridContainer.appendChild(headerDiv);

                for (let q = 0; q < circuit.qubits; q++) {
                    const rowDiv = document.createElement('div');
                    rowDiv.className = 'flex';
                    rowDiv.style.position = 'relative'; // For line anchor

                    const qubitLabel = document.createElement('div');
                    qubitLabel.className = 'w-16 h-[50px] flex items-center justify-center text-sm font-medium text-gray-700 sticky left-0 bg-gray-50 z-10 border-r border-gray-200';
                    qubitLabel.textContent = `Q${q}`;
                    rowDiv.appendChild(qubitLabel);

                    for (let c = 0; c < circuit.columns; c++) {
                        const cellDiv = document.createElement('div');
                        cellDiv.className = 'circuit-cell';
                        cellDiv.dataset.qubit = q;
                        cellDiv.dataset.column = c;
                        cellDiv.id = `cell-${q}-${c}`; // --- NEW: ID for line targeting ---

                        if (lastClickedCellCoords && lastClickedCellCoords.qubit === q && lastClickedCellCoords.column === c) {
                            cellDiv.classList.add('selected');
                        }

                        const gateSymbol = circuit.gates[q][c];
                        if (gateSymbol) {
                            const gateDiv = document.createElement('div');
                            let displaySymbol = gateSymbol;
                            let bgColor = 'bg-sky-100'; let textColor = 'text-sky-800';

                            if (gateSymbol === 'H') { bgColor = 'bg-purple-200'; textColor = 'text-purple-800'; }
                            else if (gateSymbol === 'X') { bgColor = 'bg-red-200'; textColor = 'text-red-800'; }
                            else if (gateSymbol === 'Y') { bgColor = 'bg-yellow-200'; textColor = 'text-yellow-800'; }
                            else if (gateSymbol === 'Z') { bgColor = 'bg-green-200'; textColor = 'text-green-800'; }
                            else if (gateSymbol === 'S') { bgColor = 'bg-cyan-200'; textColor = 'text-cyan-800'; }
                            else if (gateSymbol === 'T') { bgColor = 'bg-amber-200'; textColor = 'text-amber-800'; }
                            else if (gateSymbol === 'Measure') { displaySymbol = 'M'; bgColor = 'bg-gray-300'; textColor = 'text-gray-800'; }
                            else if (gateSymbol === 'CNOT-C') { displaySymbol = '●'; bgColor = 'bg-blue-300'; textColor = 'text-blue-900'; } // --- MODIFIED: Darker for control ---
                            else if (gateSymbol === 'CNOT-T') { displaySymbol = '⊕'; bgColor = 'bg-blue-200'; textColor = 'text-blue-800'; }
                            else if (gateSymbol === 'SWAP') { displaySymbol = '✕'; bgColor = 'bg-indigo-200'; textColor = 'text-indigo-800'; }

                            cellDiv.classList.add(bgColor.replace('bg-', 'border-') + '-focus', 'has-gate'); // For better focus indication
                            gateDiv.className = `gate ${bgColor} ${textColor}`;
                            gateDiv.textContent = displaySymbol;
                            cellDiv.appendChild(gateDiv);
                        }

                        if (pendingMultiQubitOp && pendingMultiQubitOp.controlQubit === q && pendingMultiQubitOp.column === c) {
                            cellDiv.classList.add('pending-control');
                            if (!gateSymbol) {
                                const pendingText = document.createElement('div');
                                pendingText.className = 'text-xs text-yellow-700 italic font-semibold'; // --- MODIFIED ---
                                pendingText.textContent = pendingMultiQubitOp.type.charAt(0) + '-Ctrl?';
                                cellDiv.appendChild(pendingText);
                            }
                        }
                        cellDiv.addEventListener('click', () => handleCellClick(q, c, cellDiv));
                        rowDiv.appendChild(cellDiv);
                    }
                    circuitGridContainer.appendChild(rowDiv);
                }
                drawConnectingLines(); // --- NEW ---
            }

            // --- NEW: Function to draw connecting lines for CNOT/SWAP ---
            function drawConnectingLines() {
                circuitLinesContainer.innerHTML = ''; // Clear previous lines

                const cellWidth = 50;
                const cellHeight = 50;
                const qubitLabelWidth = document.querySelector('.w-16').offsetWidth; // Get actual width of Qubit label column
                const colHeaderHeight = document.querySelector('.h-10').offsetHeight; // Get actual height of Column header row

                for (let c = 0; c < circuit.columns; c++) {
                    // CNOT Lines
                    const controlQubits = [];
                    const targetQubits = [];
                    for (let q = 0; q < circuit.qubits; q++) {
                        if (circuit.gates[q][c] === 'CNOT-C') controlQubits.push(q);
                        if (circuit.gates[q][c] === 'CNOT-T') targetQubits.push(q);
                    }

                    // Simplistic pairing: assumes one CNOT per column for visual simplicity.
                    // For multiple CNOTs in a column, a more robust pairing logic is needed.
                    if (controlQubits.length > 0 && targetQubits.length > 0) {
                        // For now, just connect the first found control to first found target.
                        // A better system would store pairs if multiple CNOTs allowed per column.
                        const q1 = Math.min(...controlQubits, ...targetQubits); // Topmost qubit of the CNOT
                        const q2 = Math.max(...controlQubits, ...targetQubits); // Bottommost qubit of the CNOT

                        const line = document.createElement('div');
                        line.className = 'control-line';
                        const xPos = qubitLabelWidth + (c * cellWidth) + (cellWidth / 2) - 1.5; // Center of cell, adjust for line width
                        const yTop = colHeaderHeight + (q1 * cellHeight) + (cellHeight / 2);
                        const yBottom = colHeaderHeight + (q2 * cellHeight) + (cellHeight / 2);

                        line.style.left = `${xPos}px`;
                        line.style.top = `${yTop}px`;
                        line.style.height = `${yBottom - yTop}px`;
                        circuitLinesContainer.appendChild(line);
                    }

                    // SWAP Lines
                    const swapQubits = [];
                    for (let q = 0; q < circuit.qubits; q++) {
                        if (circuit.gates[q][c] === 'SWAP') swapQubits.push(q);
                    }
                    if (swapQubits.length === 2) { // Exactly two SWAP gates for a line
                        const q1 = swapQubits[0];
                        const q2 = swapQubits[1];
                        const line = document.createElement('div');
                        line.className = 'control-line';
                        line.style.backgroundColor = '#5b21b6'; // Indigo for SWAP

                        const xPos = qubitLabelWidth + (c * cellWidth) + (cellWidth / 2) - 1.5;
                        const yTop = colHeaderHeight + (Math.min(q1, q2) * cellHeight) + (cellHeight / 2);
                        const yBottom = colHeaderHeight + (Math.max(q1, q2) * cellHeight) + (cellHeight / 2);

                        line.style.left = `${xPos}px`;
                        line.style.top = `${yTop}px`;
                        line.style.height = `${yBottom - yTop}px`;
                        circuitLinesContainer.appendChild(line);
                    }
                }
            }


            function handleCellClick(qubit, column, cellElement) {
                saveCircuitState(); // --- NEW: Save state before modification ---

                document.querySelectorAll('.circuit-cell.selected').forEach(c => c.classList.remove('selected'));
                cellElement.classList.add('selected');
                lastClickedCellCoords = { qubit, column };

                if (pendingMultiQubitOp) {
                    if (pendingMultiQubitOp.column === column && pendingMultiQubitOp.controlQubit !== qubit) {
                        const { type, controlQubit, column: controlCol } = pendingMultiQubitOp;
                        circuit.gates[controlQubit][controlCol] = null;
                        circuit.gates[qubit][column] = null;

                        if (type === 'CNOT') {
                            circuit.gates[controlQubit][controlCol] = 'CNOT-C';
                            circuit.gates[qubit][column] = 'CNOT-T';
                        } else if (type === 'SWAP') {
                            // Ensure the first clicked cell for SWAP is also marked
                            if (circuit.gates[controlQubit][controlCol] === null) {
                                circuit.gates[controlQubit][controlCol] = 'SWAP';
                            }
                            circuit.gates[qubit][column] = 'SWAP';
                        }
                        clearGateSelection();
                    } else if (pendingMultiQubitOp.column !== column) {
                        alert(`Invalid target for ${pendingMultiQubitOp.type}. Target must be in the same column (column ${pendingMultiQubitOp.column}). Cancelling operation.`);
                        clearGateSelection();
                    } else {
                        alert(`Invalid target for ${pendingMultiQubitOp.type}. Target must be a different qubit. Cancelling operation.`);
                        clearGateSelection();
                    }
                } else if (selectedGateType) {
                    if (selectedGateType === 'CNOT' || selectedGateType === 'SWAP') {
                        circuit.gates[qubit][column] = null;
                        pendingMultiQubitOp = { type: selectedGateType, controlQubit: qubit, column: column };
                        updateGateStatusDisplay();
                    } else if (selectedGateType === 'CLEAR') {
                        circuit.gates[qubit][column] = null;
                        // Check if this clear orphaned a multi-qubit gate part and clear it too
                        for (let q_other = 0; q_other < circuit.qubits; q_other++) {
                            if (q_other === qubit) continue;
                            const otherGate = circuit.gates[q_other][column];
                            if ((otherGate === 'CNOT-C' || otherGate === 'CNOT-T' || otherGate === 'SWAP')) {
                                // Simple check: if a CNOT/SWAP part exists in the same column,
                                // assume it might be orphaned. A more robust check would look for its specific partner.
                                // For now, let's be conservative and only clear the clicked cell.
                                // To clear partners, you'd need to find them and null them out.
                            }
                        }
                    } else {
                        circuit.gates[qubit][column] = selectedGateType;
                    }
                }
                renderCircuitGrid();
            }

            function clearGateSelection() {
                selectedGateType = null;
                pendingMultiQubitOp = null;
                updateSelectedGateButtonStyle();
                updateGateStatusDisplay();
                if (lastClickedCellCoords) {
                    renderCircuitGrid(); // Re-render to remove pending styles etc.
                }
            }

            function updateSelectedGateButtonStyle() {
                document.querySelectorAll('.gate-button').forEach(btn => {
                    btn.classList.remove('ring-4', 'ring-offset-2', 'ring-blue-500', 'selected-gate-button', 'scale-110', 'z-10'); // --- MODIFIED: Clearer selection style for tool ---
                    btn.classList.remove('bg-blue-300'); // Example, adapt to actual selected style
                    if (btn.getAttribute('data-gate') === selectedGateType) {
                        btn.classList.add('ring-4', 'ring-offset-2', 'ring-blue-500', 'selected-gate-button', 'scale-110', 'z-10');
                        // Example: btn.classList.add('bg-blue-300'); // Add a strong selected background
                    }
                });
            }

            function updateGateStatusDisplay() {
                if (!selectedGateType && !pendingMultiQubitOp) {
                    gateStatusSpan.textContent = "Select a gate or action."; return;
                }
                if (pendingMultiQubitOp) {
                    gateStatusSpan.textContent = `Placing ${pendingMultiQubitOp.type}. Click target qubit in column ${pendingMultiQubitOp.column}. (Qubit ${pendingMultiQubitOp.controlQubit} is control/first).`;
                } else if (selectedGateType) {
                    if (selectedGateType === 'CNOT' || selectedGateType === 'SWAP') {
                        gateStatusSpan.textContent = `Selected ${selectedGateType}. Click control/first qubit cell.`;
                    } else if (selectedGateType === 'CLEAR') {
                        gateStatusSpan.textContent = `Selected Delete. Click a cell to clear its gate.`;
                    } else {
                        gateStatusSpan.textContent = `Selected ${selectedGateType}. Click a cell to place the gate.`;
                    }
                }
            }

            function clearFullCircuit() {
                if (confirm('Are you sure you want to clear the entire circuit? This action can be undone.')) {
                    saveCircuitState(); // --- NEW: Save before clearing ---
                    circuit.gates = Array(circuit.qubits).fill(null).map(() => Array(circuit.columns).fill(null));
                    clearGateSelection();
                    renderCircuitGrid();
                    simulationResultsDiv.innerHTML = '<p class="text-gray-500 italic">Circuit cleared. Run simulation or build a new circuit.</p>';
                }
            }

            // --- QASM GENERATION & SIMULATION (largely unchanged, but ensure robustness) ---
            function generateQASM() {
                let qasmString = "OPENQASM 2.0;\n";
                qasmString += "include \"qelib1.inc\";\n";
                qasmString += `qreg q[${circuit.qubits}];\n`;

                let hasMeasurement = false;
                circuit.gates.forEach(row => row.forEach(gate => {
                    if (gate === 'Measure') hasMeasurement = true;
                }));

                if (hasMeasurement) {
                    qasmString += `creg c[${circuit.qubits}];\n`;
                }

                const processedMultiQubitInColumn = {}; // Store by column index: e.g. { 0: set(), 1: set() }

                for (let c = 0; c < circuit.columns; c++) {
                    processedMultiQubitInColumn[c] = new Set();
                    for (let q = 0; q < circuit.qubits; q++) {
                        const gate = circuit.gates[q][c];
                        if (!gate || processedMultiQubitInColumn[c].has(q)) continue; // Skip if no gate or already processed as part of multi-qubit op

                        const q_idx = `q[${q}]`;
                        const c_idx = `c[${q}]`;

                        switch (gate) {
                            case 'H': qasmString += `h ${q_idx};\n`; break;
                            case 'X': qasmString += `x ${q_idx};\n`; break;
                            case 'Y': qasmString += `y ${q_idx};\n`; break;
                            case 'Z': qasmString += `z ${q_idx};\n`; break;
                            case 'S': qasmString += `s ${q_idx};\n`; break;
                            case 'T': qasmString += `t ${q_idx};\n`; break;
                            case 'Measure': qasmString += `measure ${q_idx} -> ${c_idx};\n`; break;
                            case 'CNOT-C':
                                let targetQ_cnot = -1;
                                for (let tq = 0; tq < circuit.qubits; tq++) {
                                    if (circuit.gates[tq][c] === 'CNOT-T' && tq !== q) { targetQ_cnot = tq; break; }
                                }
                                if (targetQ_cnot !== -1) {
                                    qasmString += `cx ${q_idx},q[${targetQ_cnot}];\n`;
                                    processedMultiQubitInColumn[c].add(targetQ_cnot); // Mark target as processed for this column
                                } else { qasmString += `// Warning: CNOT-C at q[${q}],col[${c}] without valid target in same column.\n`; }
                                break;
                            case 'CNOT-T': /* Handled by CNOT-C logic */ break;
                            case 'SWAP':
                                let partnerQ_swap = -1;
                                // SWAP gates mark both qubits. Find the other one in the same column.
                                for (let pq = 0; pq < circuit.qubits; pq++) {
                                    if (pq !== q && circuit.gates[pq][c] === 'SWAP') {
                                        partnerQ_swap = pq;
                                        break;
                                    }
                                }
                                if (partnerQ_swap !== -1 && !processedMultiQubitInColumn[c].has(partnerQ_swap)) { // Ensure partner hasn't initiated this SWAP
                                    qasmString += `swap ${q_idx},q[${partnerQ_swap}];\n`;
                                    processedMultiQubitInColumn[c].add(partnerQ_swap); // Mark partner as processed
                                } else if (partnerQ_swap === -1) {
                                    qasmString += `// Warning: SWAP at q[${q}],col[${c}] without a partner in the same column.\n`;
                                }
                                break;
                            default: qasmString += `// Unknown gate '${gate}' at q[${q}],col[${c}]\n`;
                        }
                        processedMultiQubitInColumn[c].add(q); // Mark current qubit as processed for this gate/operation
                    }
                }
                return qasmString;
            }


            async function runSimulationWithBackend() {
                const qasmCode = generateQASM();

                let htmlOutput = "<h3>Generated QASM 2.0:</h3>";
                htmlOutput += `<pre class="whitespace-pre-wrap break-all text-sm p-2 bg-gray-100 rounded border">${qasmCode.replace(/</g, "<").replace(/>/g, ">")}</pre>`; // --- MODIFIED: styling ---
                htmlOutput += "<hr class='my-4 border-gray-300'>";
                htmlOutput += "<h3>Simulation Results:</h3>";

                simulationResultsDiv.innerHTML = htmlOutput + "<p class='text-indigo-600 animate-pulse mt-2 font-medium'>Sending QASM to backend and awaiting simulation results...</p>";
                console.log("Generated QASM for Backend Simulation:\n", qasmCode);

                try {
                    const payload = { qasm: qasmCode, shots: 1024 };
                    const response = await fetch(FLASK_BACKEND_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', },
                        body: JSON.stringify(payload)
                    });
                    const resultData = await response.json();

                    htmlOutput = simulationResultsDiv.innerHTML.split("<hr class='my-4 border-gray-300'>")[0] + "<hr class='my-4 border-gray-300'>";
                    htmlOutput += "<h3>Simulation Results:</h3>";

                    if (!response.ok) {
                        console.error("Backend error:", resultData);
                        throw new Error(resultData.error || `Backend Error: ${response.status} ${response.statusText}`);
                    }

                    htmlOutput += `<p class="text-green-700 font-semibold"><strong>Status:</strong> ${resultData.message || 'Success!'}</p>`;
                    if (resultData.job_id) { htmlOutput += `<p class="text-sm text-gray-600"><strong>Job ID:</strong> ${resultData.job_id}</p>`; }
                    htmlOutput += `<p class="text-sm text-gray-600"><strong>Backend Used:</strong> ${resultData.backend_used || 'N/A'}</p>`;
                    htmlOutput += `<p class="text-sm text-gray-600"><strong>Shots:</strong> ${resultData.shots || 'N/A'}</p>`;
                    htmlOutput += `<h4 class="font-semibold mt-3 mb-1 text-gray-700">Counts:</h4>`;

                    if (resultData.counts && Object.keys(resultData.counts).length > 0) {
                        htmlOutput += `<pre class="text-sm whitespace-pre-wrap break-all p-2 bg-gray-100 rounded border">${JSON.stringify(resultData.counts, null, 2)}</pre>`;
                    } else {
                        htmlOutput += `<p class="text-sm italic text-gray-500">No counts returned or circuit has no measurements / classical bits.</p>`;
                    }
                    simulationResultsDiv.innerHTML = htmlOutput;
                } catch (error) {
                    console.error("Error during Backend Simulation or fetching results:", error);
                    let errorHTML = simulationResultsDiv.innerHTML.split("<hr class='my-4 border-gray-300'>")[0] + "<hr class='my-4 border-gray-300'>";
                    errorHTML += "<h3>Simulation Results:</h3>";
                    errorHTML += `<p class='text-red-600 mt-2 font-semibold'><strong>Error:</strong> ${error.message}</p>`;
                    errorHTML += `<p class='text-sm text-gray-600 mt-1'>Ensure backend server (${FLASK_BACKEND_URL}) is running and accessible. Check browser console and backend server logs for details.</p>`;
                    simulationResultsDiv.innerHTML = errorHTML;
                }
            }

            // --- IMPORT/EXPORT ---
            function exportCircuitToJSON() { /* ... (keep existing, good as is) ... */
                const circuitData = { qubits: circuit.qubits, columns: circuit.columns, gates: circuit.gates };
                const dataStr = JSON.stringify(circuitData, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
                const exportFileDefaultName = `quantum-circuit-${new Date().toISOString().slice(0, 10)}.json`;
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
            }
            function showImportModal() { /* ... (keep existing) ... */
                importJsonTextarea.value = ''; importJsonModal.classList.remove('hidden');
            }
            function hideImportModal() { importJsonModal.classList.add('hidden'); }

            function importCircuitFromJSON() {
                saveCircuitState(); // --- NEW: Save state before import ---
                try {
                    const imported = JSON.parse(importJsonTextarea.value);
                    if (!imported.qubits || !imported.columns || !Array.isArray(imported.gates)) {
                        throw new Error('Invalid circuit data. Missing qubits, columns, or gates array.');
                    }
                    if (imported.gates.length !== imported.qubits || (imported.qubits > 0 && imported.gates[0].length !== imported.columns)) {
                        throw new Error('Gate array dimensions do not match qubit and column counts.');
                    }

                    circuit.qubits = imported.qubits;
                    circuit.columns = imported.columns;
                    circuit.gates = imported.gates;

                    qubitCountInput.value = circuit.qubits;
                    columnCountInput.value = circuit.columns;

                    clearGateSelection();
                    renderCircuitGrid();
                    hideImportModal();
                    simulationResultsDiv.innerHTML = '<p class="text-gray-500 italic">Circuit imported. Run simulation.</p>';
                } catch (error) {
                    alert('Error importing circuit: ' + error.message);
                    // If import fails, we might want to revert to the saved state, but that's complex.
                    // For now, the invalid import attempt won't create a new history entry if it errors out before render.
                }
            }

            // --- PREBUILT CIRCUITS ---
            function loadPrebuiltCircuit() {
                const circuitType = prebuiltCircuitsSelect.value;
                if (!circuitType) return;
                saveCircuitState(); // --- NEW: Save state before loading ---
                let newCircuitData;
                switch (circuitType) {
                    case 'bell':
                        newCircuitData = { qubits: 2, columns: 2, gates: [['H', 'CNOT-C'], [null, 'CNOT-T']] };
                        break;
                    case 'ghz':
                        newCircuitData = { qubits: 3, columns: 3, gates: [['H', 'CNOT-C', null], [null, 'CNOT-T', 'CNOT-C'], [null, null, 'CNOT-T']] };
                        break;
                    case 'teleport': // --- NEW: Teleportation ---
                        newCircuitData = {
                            qubits: 3, columns: 7,
                            gates: [
                                // Q0: Qubit to teleport, Q1: Alice's Bell pair half, Q2: Bob's Bell pair half
                                [null, 'H', 'CNOT-C', null, 'H', 'Measure', null],      // Q0 (psi)
                                ['H', 'CNOT-C', 'CNOT-T', 'Measure', null, null, 'X'],  // Q1 (Alice) - X controlled by Q0 Measure
                                ['CNOT-T', null, null, 'Measure', null, null, 'Z']      // Q2 (Bob) - Z controlled by Q1 Measure
                                // Note: Actual QASM for controlled X/Z from measurement requires `if` classically,
                                // This is a simplified visual representation. QASM generated will be direct.
                            ]
                        };
                        // For a true teleportation, the last X and Z are classically controlled.
                        // This representation is a common way to show it in circuit diagrams before actual conditional logic.
                        // The QASM generated will apply them unconditionally if "Measure" isn't linked to conditions.
                        // A more advanced QASM generator would handle `if (creg==val) gate;`
                        alert("Note: The teleportation circuit's final X and Z gates on Bob's qubit (Q2) are typically classically controlled by Alice's measurement outcomes. This visualizer applies them directly for simplicity in QASM generation. A full quantum backend handles conditional operations based on measurement.");
                        break;
                    default: return;
                }
                circuit.qubits = newCircuitData.qubits;
                circuit.columns = newCircuitData.columns;
                circuit.gates = newCircuitData.gates;
                qubitCountInput.value = circuit.qubits;
                columnCountInput.value = circuit.columns;
                clearGateSelection();
                renderCircuitGrid();
                simulationResultsDiv.innerHTML = `<p class="text-gray-500 italic">${circuitType} circuit loaded. Run simulation.</p>`;
                prebuiltCircuitsSelect.value = '';
            }

            // --- AI TOOLS (OpenRouter) ---
            function showAiBuildModal() { /* ... (keep existing) ... */
                aiBuildPromptTextarea.value = ''; aiBuildModal.classList.remove('hidden');
            }
            function hideAiBuildModal() { aiBuildModal.classList.add('hidden'); }

            async function buildCircuitWithAI() {
                const userPrompt = aiBuildPromptTextarea.value.trim();
                if (!userPrompt) { alert('Please describe the circuit.'); return; }
                if (!OPENROUTER_API_KEY || OPENROUTER_API_KEY === YOUR_OPENROUTER_API_KEY_PLACEHOLDER) {
                    alert("OpenRouter API Key not configured. AI features disabled.");
                    simulationResultsDiv.innerHTML = "<p class='text-red-500'>AI Build disabled: OpenRouter API Key not set.</p>";
                    hideAiBuildModal();
                    return;
                }
                saveCircuitState(); // --- NEW: Save state before AI build ---
                hideAiBuildModal();
                simulationResultsDiv.innerHTML = '<p class="text-indigo-600 animate-pulse font-medium">Generating circuit with AI...</p>';

                try {
                    // ... (rest of AI build logic, ensure it's robust) ...
                    const response = await fetch(OPENROUTER_API_URL, { /* ... */ });
                    // ...
                    const data = await response.json();
                    if (!response.ok) throw new Error(data.error?.message || 'AI API error');

                    const aiResponseContent = data.choices[0].message.content;
                    let circuitData;
                    try {
                        const jsonMatch = aiResponseContent.match(/```json\n([\s\S]*?)\n```/);
                        circuitData = JSON.parse(jsonMatch ? jsonMatch[1] : aiResponseContent);
                    } catch (e) { throw new Error('AI response was not valid JSON: ' + e.message + "\nResponse: " + aiResponseContent); }

                    if (!circuitData.qubits || !circuitData.columns || !Array.isArray(circuitData.gates) || !circuitData.description) {
                        throw new Error('AI response missing required fields (qubits, columns, gates, description).');
                    }
                    if (circuitData.gates.length !== circuitData.qubits ||
                        (circuitData.qubits > 0 && circuitData.gates.some(row => !Array.isArray(row) || row.length !== circuitData.columns))) {
                        throw new Error('AI response gate array dimensions do not match qubit and column counts or is malformed.');
                    }

                    circuit.qubits = circuitData.qubits;
                    circuit.columns = circuitData.columns;
                    circuit.gates = circuitData.gates; // Make sure gates are valid
                    qubitCountInput.value = circuit.qubits;
                    columnCountInput.value = circuit.columns;
                    clearGateSelection();
                    renderCircuitGrid();
                    simulationResultsDiv.innerHTML = `<div><p class="font-semibold text-green-700 mb-1">AI-Generated Circuit:</p><p class="text-sm mb-2">${circuitData.description}</p><button onclick="document.getElementById('run-simulation-btn').click()" class="px-3 py-1.5 bg-green-600 text-white rounded-md text-sm shadow hover:shadow-md transition-all">Run Simulation</button></div>`;
                } catch (error) {
                    simulationResultsDiv.innerHTML = `<div class="text-red-600"><p class="font-semibold">Error with AI Build:</p><p class="text-sm">${error.message}</p></div>`;
                    console.error('AI Build error:', error);
                    // Potentially revert to saved state if AI build fails significantly
                }
            }

            async function explainCircuitAI() { /* ... (keep existing, ensure good error display) ... */
                if (circuit.gates.every(row => row.every(gate => gate === null))) {
                    alert('Circuit is empty. Add gates first.'); return;
                }
                if (!OPENROUTER_API_KEY || OPENROUTER_API_KEY === YOUR_OPENROUTER_API_KEY_PLACEHOLDER) {
                    alert("OpenRouter API Key not configured. AI features disabled.");
                    simulationResultsDiv.innerHTML = "<p class='text-red-500'>AI Explain disabled: OpenRouter API Key not set.</p>";
                    return;
                }
                simulationResultsDiv.innerHTML = '<p class="text-indigo-600 animate-pulse font-medium">AI is generating explanation...</p>';
                try {
                    const response = await fetch(OPENROUTER_API_URL, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Quantum Circuit Simulator'
                        },
                        body: JSON.stringify({
                            model: "openai/gpt-3.5-turbo", // Or "mistralai/mistral-7b-instruct" for potentially cheaper/faster
                            messages: [
                                { role: "system", content: "You are a quantum computing educator. Explain the given circuit (qubits, columns, gates array) concisely in markdown. Identify standard algorithms if any. Use clear, beginner-friendly language but be accurate." },
                                { role: "user", content: `Explain this circuit: Qubits: ${circuit.qubits}, Columns: ${circuit.columns}, Gates: ${JSON.stringify(circuit.gates)}` }
                            ],
                            temperature: 0.4
                        })
                    });
                    const data = await response.json();
                    if (!response.ok) throw new Error(data.error?.message || 'AI API error');
                    const explanation = data.choices[0].message.content;

                    const formattedExplanation = explanation // Keep your markdown formatting
                        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                        .replace(/\*(.*?)\*/g, '<em>$1</em>')
                        .replace(/```([\s\S]*?)```/g, '<pre class="bg-gray-200 p-2 rounded text-sm my-1 whitespace-pre-wrap">$1</pre>')
                        .replace(/`(.*?)`/g, '<code class="bg-gray-200 px-1 rounded text-sm">$1</code>')
                        .replace(/\n/g, '<br/>');

                    simulationResultsDiv.innerHTML = `<div><p class="font-semibold text-purple-700 mb-2">AI Circuit Explanation:</p><div class="prose prose-sm max-w-none">${formattedExplanation}</div></div>`;
                } catch (error) {
                    simulationResultsDiv.innerHTML = `<div class="text-red-600"><p class="font-semibold">Error with AI Explanation:</p><p class="text-sm">${error.message}</p></div>`;
                    console.error('AI Explain error:', error);
                }
            }

            // --- AI CHAT (largely unchanged, but ensure good error display & UI) ---
            function addMessageToChatUI(role, content, id = null) { /* ... (keep existing, ensure styling is good) ... */
                const messageDiv = document.createElement('div');
                messageDiv.className = `chat-message ${role === 'user' ? 'user-message' : 'ai-message'}`;
                if (id) messageDiv.id = id;

                const formattedContent = content
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/```([\s\S]*?)```/g, (match, p1) => `<pre class="bg-gray-300 text-gray-800 p-2 rounded text-sm my-1 whitespace-pre-wrap">${p1.trim()}</pre>`)
                    .replace(/`(.*?)`/g, '<code class="bg-gray-300 text-gray-800 px-1 rounded text-sm">$1</code>')
                    .replace(/\n/g, '<br/>');

                messageDiv.innerHTML = `<div class="prose prose-sm max-w-none">${formattedContent}</div>`;
                chatMessagesContainer.appendChild(messageDiv);
                chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
            }

            async function sendChatMessage() { /* ... (keep existing logic) ... */
                const userMessage = chatInputField.value.trim();
                if (!userMessage) return;
                if (!OPENROUTER_API_KEY || OPENROUTER_API_KEY === YOUR_OPENROUTER_API_KEY_PLACEHOLDER) {
                    addMessageToChatUI('assistant', "AI Tutor disabled: OpenRouter API Key not configured in the script.");
                    chatInputField.value = '';
                    return;
                }

                addMessageToChatUI('user', userMessage);
                aiChatHistory.push({ role: 'user', content: userMessage });
                chatInputField.value = '';

                const loadingId = 'ai-loading-' + Date.now();
                addMessageToChatUI('assistant', '<span class="italic text-gray-600">Tutor is thinking...</span>', loadingId);

                try {
                    const response = await fetch(OPENROUTER_API_URL, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.href,
                            'X-Title': 'Quantum Circuit Simulator'
                        },
                        body: JSON.stringify({
                            model: "openai/gpt-3.5-turbo", // Or "mistralai/mistral-7b-instruct"
                            messages: [
                                { role: "system", content: "You are a Quantum Computing Tutor. Answer concisely in markdown. Explain concepts clearly for beginners. If asked to write code, prefer Qiskit/Python examples unless specified." },
                                ...aiChatHistory.slice(-12) // Send more history if needed
                            ],
                            temperature: 0.5
                        })
                    });
                    const data = await response.json();
                    const loadingElement = document.getElementById(loadingId);

                    if (!response.ok) {
                        const errorMsg = data.error?.message || 'AI chat API error';
                        if (loadingElement) loadingElement.innerHTML = `<div class="prose prose-sm text-red-600">Error: ${errorMsg}</div>`;
                        else addMessageToChatUI('assistant', `Error: ${errorMsg}`);
                        throw new Error(errorMsg);
                    }

                    const aiResponse = data.choices[0].message.content;
                    aiChatHistory.push({ role: 'assistant', content: aiResponse });
                    if (loadingElement) {
                        const formattedResponse = aiResponse
                            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                            .replace(/\*(.*?)\*/g, '<em>$1</em>')
                            .replace(/```([\s\S]*?)```/g, (match, p1) => `<pre class="bg-gray-300 text-gray-800 p-2 rounded text-sm my-1 whitespace-pre-wrap">${p1.trim()}</pre>`)
                            .replace(/`(.*?)`/g, '<code class="bg-gray-300 text-gray-800 px-1 rounded text-sm">$1</code>')
                            .replace(/\n/g, '<br/>');
                        loadingElement.innerHTML = `<div class="prose prose-sm max-w-none">${formattedResponse}</div>`;
                    } else {
                        addMessageToChatUI('assistant', aiResponse);
                    }

                } catch (error) {
                    console.error('AI Chat error:', error);
                    const loadingElement = document.getElementById(loadingId);
                    if (loadingElement) loadingElement.innerHTML = `<div class="prose prose-sm text-red-600">Chat Error: ${error.message}</div>`;
                    else addMessageToChatUI('assistant', `Chat Error: ${error.message}`);
                }
            }


            // --- EVENT LISTENERS ---
            function setupEventListeners() {
                updateCircuitBtn.addEventListener('click', () => initializeCircuitState(true)); // Pass true for user action

                document.querySelectorAll('.gate-button').forEach(button => {
                    button.addEventListener('click', function () {
                        const gateType = this.getAttribute('data-gate');
                        if (selectedGateType === gateType && !pendingMultiQubitOp) {
                            clearGateSelection();
                        } else {
                            selectedGateType = gateType;
                            pendingMultiQubitOp = null;
                            updateSelectedGateButtonStyle();
                            updateGateStatusDisplay();
                        }
                    });
                });

                runSimulationBtn.addEventListener('click', runSimulationWithBackend);
                clearCircuitBtn.addEventListener('click', clearFullCircuit);
                undoCircuitBtn.addEventListener('click', undoLastAction); // --- NEW ---
                exportCircuitBtn.addEventListener('click', exportCircuitToJSON);

                importCircuitBtn.addEventListener('click', showImportModal);
                cancelImportJsonBtn.addEventListener('click', hideImportModal);
                submitImportJsonBtn.addEventListener('click', importCircuitFromJSON);

                prebuiltCircuitsSelect.addEventListener('change', loadPrebuiltCircuit);

                buildWithAiBtn.addEventListener('click', showAiBuildModal);
                cancelAiBuildBtn.addEventListener('click', hideAiBuildModal);
                submitAiBuildBtn.addEventListener('click', buildCircuitWithAI);
                explainCircuitAiBtn.addEventListener('click', explainCircuitAI);

                sendChatBtn.addEventListener('click', sendChatMessage);
                chatInputField.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        sendChatMessage();
                    }
                });
                updateUndoButtonState(); // Initialize undo button state
            }
        });
    </script>
</body>

</html>